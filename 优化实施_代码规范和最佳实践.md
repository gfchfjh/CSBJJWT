# KOOKè½¬å‘ç³»ç»Ÿä¼˜åŒ– - ä»£ç è§„èŒƒå’Œæœ€ä½³å®è·µ

**ç‰ˆæœ¬**: v1.0  
**é€‚ç”¨èŒƒå›´**: æ‰€æœ‰ä¼˜åŒ–å¼€å‘

---

## ğŸ“‹ ç›®å½•

- [ä»£ç é£æ ¼è§„èŒƒ](#ä»£ç é£æ ¼è§„èŒƒ)
- [å‘½åè§„èŒƒ](#å‘½åè§„èŒƒ)
- [æ³¨é‡Šè§„èŒƒ](#æ³¨é‡Šè§„èŒƒ)
- [é”™è¯¯å¤„ç†è§„èŒƒ](#é”™è¯¯å¤„ç†è§„èŒƒ)
- [æ€§èƒ½ä¼˜åŒ–åŸåˆ™](#æ€§èƒ½ä¼˜åŒ–åŸåˆ™)
- [å®‰å…¨ç¼–ç è§„èŒƒ](#å®‰å…¨ç¼–ç è§„èŒƒ)

---

## ä»£ç é£æ ¼è§„èŒƒ

### Pythonåç«¯ä»£ç é£æ ¼

#### éµå¾ªPEP 8æ ‡å‡†

```python
# âœ… å¥½çš„ç¤ºä¾‹
class MessageWorker:
    """æ¶ˆæ¯å¤„ç†Workerï¼ˆæ–‡æ¡£å­—ç¬¦ä¸²å¿…éœ€ï¼‰"""
    
    def __init__(self):
        self.is_running = False
        self._processed_messages = set()
    
    async def process_message(self, message: Dict[str, Any]) -> bool:
        """
        å¤„ç†å•æ¡æ¶ˆæ¯
        
        Args:
            message: æ¶ˆæ¯æ•°æ®å­—å…¸
            
        Returns:
            æ˜¯å¦å¤„ç†æˆåŠŸ
            
        Raises:
            ValueError: æ¶ˆæ¯æ ¼å¼ä¸æ­£ç¡®
        """
        if not message.get('message_id'):
            raise ValueError("ç¼ºå°‘message_id")
        
        # ä¸šåŠ¡é€»è¾‘...
        return True


# âŒ åçš„ç¤ºä¾‹
class messageWorker:  # ç±»ååº”ä½¿ç”¨é©¼å³°å‘½å
    def process(self,message):  # ç¼ºå°‘ç±»å‹æ³¨è§£å’Œæ–‡æ¡£å­—ç¬¦ä¸²
        if not message.get('message_id'):return False  # åº”è¯¥åˆ†è¡Œ
        return True
```

#### ç±»å‹æ³¨è§£

```python
# âœ… å¿…é¡»æ·»åŠ ç±»å‹æ³¨è§£
from typing import List, Dict, Any, Optional, Tuple

async def get_logs(
    limit: int = 100,
    offset: int = 0,
    status: Optional[str] = None
) -> Tuple[List[Dict[str, Any]], int]:
    """ç±»å‹æ³¨è§£æ¸…æ™°"""
    pass


# âŒ ä¸è¦çœç•¥ç±»å‹æ³¨è§£
async def get_logs(limit=100, offset=0, status=None):
    """ç±»å‹ä¸æ˜ç¡®"""
    pass
```

#### å¼‚æ­¥ä»£ç è§„èŒƒ

```python
# âœ… æ­£ç¡®çš„å¼‚æ­¥è°ƒç”¨
async def forward_message(message: dict) -> bool:
    # ä½¿ç”¨await
    result = await api.send_message(message)
    
    # å¹¶å‘å¤„ç†
    results = await asyncio.gather(
        api.send_to_discord(message),
        api.send_to_telegram(message),
        return_exceptions=True
    )
    
    return all(results)


# âŒ é”™è¯¯çš„å¼‚æ­¥è°ƒç”¨
async def forward_message(message: dict) -> bool:
    # å¿˜è®°await
    result = api.send_message(message)  # è¿”å›çš„æ˜¯coroutineå¯¹è±¡
    
    # ä¸²è¡Œå¤„ç†ï¼ˆåº”è¯¥å¹¶å‘ï¼‰
    await api.send_to_discord(message)
    await api.send_to_telegram(message)
    
    return True
```

---

### Vueå‰ç«¯ä»£ç é£æ ¼

#### ç»„ä»¶ç»“æ„è§„èŒƒ

```vue
<!-- âœ… æ¨èçš„ç»„ä»¶ç»“æ„ -->
<template>
  <div class="component-name">
    <!-- æ¸…æ™°çš„HTMLç»“æ„ -->
  </div>
</template>

<script setup>
// 1. å¯¼å…¥
import { ref, computed, onMounted } from 'vue'
import { ElMessage } from 'element-plus'
import { Icon } from '@element-plus/icons-vue'

// 2. Propså®šä¹‰
const props = defineProps({
  modelValue: {
    type: String,
    required: true
  }
})

// 3. Emitså®šä¹‰
const emit = defineEmits(['update:modelValue', 'change'])

// 4. å“åº”å¼æ•°æ®
const data = ref([])
const loading = ref(false)

// 5. è®¡ç®—å±æ€§
const filteredData = computed(() => {
  return data.value.filter(item => item.active)
})

// 6. æ–¹æ³•
const handleClick = () => {
  // ä¸šåŠ¡é€»è¾‘
}

// 7. ç”Ÿå‘½å‘¨æœŸ
onMounted(() => {
  // åˆå§‹åŒ–é€»è¾‘
})
</script>

<style scoped lang="scss">
/* ä½¿ç”¨SCSS */
.component-name {
  .child-element {
    // åµŒå¥—æ ·å¼
  }
}
</style>
```

#### Composition APIè§„èŒƒ

```vue
<script setup>
// âœ… æ¨èï¼šä½¿ç”¨Composition API

import { ref, computed } from 'vue'

const count = ref(0)
const doubleCount = computed(() => count.value * 2)

const increment = () => {
  count.value++
}


// âŒ ä¸æ¨èï¼šåœ¨ä¼˜åŒ–ä»£ç ä¸­ä½¿ç”¨Options API
export default {
  data() {
    return {
      count: 0
    }
  },
  computed: {
    doubleCount() {
      return this.count * 2
    }
  }
}
</script>
```

---

## å‘½åè§„èŒƒ

### æ–‡ä»¶å‘½å

```
å‰ç«¯æ–‡ä»¶:
âœ… PascalCase: UserProfile.vue, AccountCard.vue
âœ… kebab-case: user-profile.css, account-card.scss

åç«¯æ–‡ä»¶:
âœ… snake_case: user_manager.py, message_processor.py
âœ… kebab-case: requirements-dev.txt, docker-compose.yml
```

### å˜é‡å‘½å

```python
# Python
âœ… å˜é‡: snake_case
user_name = "John"
message_count = 10

âœ… å¸¸é‡: UPPER_SNAKE_CASE
MAX_RETRY_COUNT = 3
DEFAULT_TIMEOUT = 30

âœ… ç±»å: PascalCase
class MessageWorker:
    pass

âœ… ç§æœ‰å˜é‡: _leading_underscore
self._connection = None
```

```javascript
// JavaScript/Vue
âœ… å˜é‡: camelCase
const userName = 'John'
const messageCount = 10

âœ… å¸¸é‡: UPPER_SNAKE_CASE
const MAX_RETRY_COUNT = 3
const DEFAULT_TIMEOUT = 30

âœ… ç»„ä»¶å: PascalCase
const UserProfile = defineComponent({})

âœ… Props: camelCase
const props = defineProps({
  userName: String
})
```

### å‡½æ•°å‘½å

```python
# âœ… åŠ¨è¯å¼€å¤´ï¼Œæ¸…æ™°è¡¨è¾¾æ„å›¾
async def get_user_by_id(user_id: int) -> Optional[User]:
    """è·å–ç”¨æˆ·"""
    pass

async def create_bot_config(config: dict) -> int:
    """åˆ›å»ºBoté…ç½®"""
    pass

def is_valid_email(email: str) -> bool:
    """éªŒè¯é‚®ç®±æ ¼å¼"""
    pass

# âŒ å‘½åä¸æ¸…æ™°
async def user(id):
    pass

async def handle(config):
    pass
```

---

## æ³¨é‡Šè§„èŒƒ

### æ–‡æ¡£å­—ç¬¦ä¸²

```python
# âœ… å®Œæ•´çš„æ–‡æ¡£å­—ç¬¦ä¸²
async def send_message(
    self,
    webhook_url: str,
    content: str,
    username: Optional[str] = None
) -> bool:
    """
    å‘é€æ¶ˆæ¯åˆ°Discord
    
    è¿™ä¸ªæ–¹æ³•ä¼šè‡ªåŠ¨å¤„ç†ï¼š
    - æ¶ˆæ¯é•¿åº¦é™åˆ¶ï¼ˆ2000å­—ç¬¦ï¼‰
    - é™æµæ§åˆ¶ï¼ˆ5æ¡/5ç§’ï¼‰
    - é”™è¯¯é‡è¯•ï¼ˆæœ€å¤š3æ¬¡ï¼‰
    
    Args:
        webhook_url: Discord Webhookå®Œæ•´URL
        content: æ¶ˆæ¯å†…å®¹ï¼ˆæ”¯æŒMarkdownï¼‰
        username: æ˜¾ç¤ºçš„ç”¨æˆ·åï¼ˆå¯é€‰ï¼Œé»˜è®¤"KOOKæ¶ˆæ¯è½¬å‘"ï¼‰
        
    Returns:
        True: å‘é€æˆåŠŸ
        False: å‘é€å¤±è´¥
        
    Raises:
        ValueError: webhook_urlæ ¼å¼ä¸æ­£ç¡®
        TimeoutError: è¯·æ±‚è¶…æ—¶ï¼ˆ>30ç§’ï¼‰
        
    Example:
        >>> await forwarder.send_message(
        ...     webhook_url="https://discord.com/api/webhooks/123/abc",
        ...     content="Hello World",
        ...     username="Bot"
        ... )
        True
        
    Note:
        - è¶…é•¿æ¶ˆæ¯ä¼šè‡ªåŠ¨åˆ†æ®µå‘é€
        - å›¾ç‰‡URLä¼šè‡ªåŠ¨è½¬æ¢ä¸ºEmbed
        
    See Also:
        - send_with_attachment(): å‘é€å¸¦é™„ä»¶çš„æ¶ˆæ¯
        - send_embed(): å‘é€Embedå¡ç‰‡
    """
    pass
```

### è¡Œå†…æ³¨é‡Š

```python
# âœ… å¥½çš„æ³¨é‡Šï¼šè§£é‡Š"ä¸ºä»€ä¹ˆ"

# ä½¿ç”¨LRUç¼“å­˜é˜²æ­¢å†…å­˜æ³„æ¼ï¼ˆæœ€å¤š10,000æ¡ï¼‰
self.processed_messages = LRUCache(max_size=10000)

# Discordé™æµï¼š5æ¡/5ç§’ï¼ˆå®˜æ–¹é™åˆ¶ï¼‰
await self.rate_limiter.acquire()

# é‡è¯•3æ¬¡åæ”¾å¼ƒï¼Œé¿å…æ— é™å¾ªç¯
if retry_count >= 3:
    logger.error("é‡è¯•æ¬¡æ•°å·²è¾¾ä¸Šé™")
    return False


# âŒ åçš„æ³¨é‡Šï¼šé‡å¤ä»£ç å†…å®¹

# è®¾ç½®å˜é‡ä¸º10
max_retry = 10

# å¦‚æœcountå¤§äº0
if count > 0:
    # è¿”å›True
    return True
```

### TODOæ³¨é‡Š

```python
# âœ… è§„èŒƒçš„TODOæ³¨é‡Š
# TODO(P0): å®ç°éªŒè¯ç è‡ªåŠ¨è¯†åˆ« - é¢„è®¡6å°æ—¶ [@developer_name] [2025-10-26]
# TODO(P1): ä¼˜åŒ–å›¾ç‰‡å‹ç¼©ç®—æ³• - æ€§èƒ½æå‡50% [@developer_name] [2025-11-01]
# FIXME: Redisè¿æ¥å¶å°”è¶…æ—¶ï¼Œéœ€è¦æ·»åŠ é‡è¯•æœºåˆ¶
# HACK: ä¸´æ—¶ç»•è¿‡KOOKçš„é˜²ç›—é“¾æ£€æŸ¥ï¼Œéœ€è¦æ›´ä¼˜é›…çš„æ–¹æ¡ˆ
# NOTE: è¿™ä¸ªæ–¹æ³•åœ¨v4.0ä¼šè¢«åºŸå¼ƒï¼Œå»ºè®®ä½¿ç”¨new_method()

# âŒ ä¸è§„èŒƒçš„TODO
# TODO: fix this
# TODO: ä¼˜åŒ–
```

---

## é”™è¯¯å¤„ç†è§„èŒƒ

### å¼‚å¸¸æ•è·

```python
# âœ… å…·ä½“å¼‚å¸¸ï¼Œæ¸…æ™°å¤„ç†
async def download_image(url: str) -> bytes:
    """ä¸‹è½½å›¾ç‰‡"""
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(url, timeout=30) as response:
                if response.status != 200:
                    raise HTTPException(
                        status_code=response.status,
                        detail=f"ä¸‹è½½å¤±è´¥: HTTP {response.status}"
                    )
                return await response.read()
    
    except asyncio.TimeoutError:
        logger.error(f"ä¸‹è½½è¶…æ—¶: {url}")
        raise TimeoutError(f"å›¾ç‰‡ä¸‹è½½è¶…æ—¶ï¼ˆ>30ç§’ï¼‰: {url}")
    
    except aiohttp.ClientError as e:
        logger.error(f"ç½‘ç»œé”™è¯¯: {str(e)}")
        raise ConnectionError(f"ç½‘ç»œè¿æ¥å¤±è´¥: {str(e)}")
    
    except Exception as e:
        logger.error(f"æœªçŸ¥é”™è¯¯: {str(e)}", exc_info=True)
        raise RuntimeError(f"ä¸‹è½½å›¾ç‰‡æ—¶å‘ç”ŸæœªçŸ¥é”™è¯¯: {str(e)}")


# âŒ ç¬¼ç»Ÿæ•è·ï¼Œä¿¡æ¯ä¸è¶³
async def download_image(url: str) -> bytes:
    try:
        # ... ä¸šåŠ¡é€»è¾‘
        pass
    except Exception as e:
        print(f"Error: {e}")  # ä¸åº”è¯¥ç”¨print
        return None  # ä¸åº”è¯¥åæ‰å¼‚å¸¸
```

### é”™è¯¯æ—¥å¿—

```python
# âœ… ç»“æ„åŒ–æ—¥å¿—

logger.error(
    "æ¶ˆæ¯è½¬å‘å¤±è´¥",
    extra={
        'message_id': message['message_id'],
        'channel_id': message['channel_id'],
        'target_platform': 'discord',
        'error_type': 'rate_limit',
        'retry_count': 2
    }
)


# âŒ ç®€å•å­—ç¬¦ä¸²æ—¥å¿—

logger.error("è½¬å‘å¤±è´¥")  # ä¿¡æ¯ä¸è¶³
```

---

## æ€§èƒ½ä¼˜åŒ–åŸåˆ™

### æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–

```python
# âœ… ä½¿ç”¨ç´¢å¼•
async def get_recent_logs(limit: int = 100):
    """åˆ©ç”¨created_atç´¢å¼•"""
    async with db.cursor() as cursor:
        await cursor.execute("""
            SELECT * FROM message_logs 
            WHERE created_at > datetime('now', '-1 day')
            ORDER BY created_at DESC 
            LIMIT ?
        """, (limit,))
        return await cursor.fetchall()


# âŒ å…¨è¡¨æ‰«æ
async def get_recent_logs(limit: int = 100):
    """æ€§èƒ½å·®"""
    async with db.cursor() as cursor:
        await cursor.execute("""
            SELECT * FROM message_logs 
            WHERE strftime('%Y-%m-%d', created_at) = date('now')
        """)  # å‡½æ•°è°ƒç”¨æ— æ³•ä½¿ç”¨ç´¢å¼•
        return await cursor.fetchall()
```

### é¿å…N+1æŸ¥è¯¢

```python
# âœ… ä½¿ç”¨JOINï¼Œä¸€æ¬¡æŸ¥è¯¢
async def get_mappings_with_bots():
    """ä¸€æ¬¡æ€§è·å–æ˜ å°„å’ŒBoté…ç½®"""
    async with db.cursor() as cursor:
        await cursor.execute("""
            SELECT 
                cm.*,
                bc.name as bot_name,
                bc.platform as bot_platform
            FROM channel_mappings cm
            JOIN bot_configs bc ON cm.target_bot_id = bc.id
            WHERE cm.enabled = 1
        """)
        return await cursor.fetchall()


# âŒ N+1æŸ¥è¯¢
async def get_mappings_with_bots():
    """ä½æ•ˆï¼šæ¯ä¸ªæ˜ å°„æŸ¥è¯¢ä¸€æ¬¡Bot"""
    mappings = await get_all_mappings()
    
    for mapping in mappings:
        # å¾ªç¯ä¸­æŸ¥è¯¢æ•°æ®åº“ï¼
        bot = await get_bot_config(mapping['target_bot_id'])
        mapping['bot_name'] = bot['name']
    
    return mappings
```

### å¹¶å‘ä¼˜åŒ–

```python
# âœ… å¹¶è¡Œå¤„ç†
async def process_images(image_urls: List[str]) -> List[bytes]:
    """å¹¶è¡Œä¸‹è½½æ‰€æœ‰å›¾ç‰‡"""
    tasks = [download_image(url) for url in image_urls]
    results = await asyncio.gather(*tasks, return_exceptions=True)
    
    # è¿‡æ»¤å¼‚å¸¸
    images = [r for r in results if isinstance(r, bytes)]
    return images


# âŒ ä¸²è¡Œå¤„ç†
async def process_images(image_urls: List[str]) -> List[bytes]:
    """ä½æ•ˆï¼šé€ä¸ªä¸‹è½½"""
    images = []
    for url in image_urls:
        image = await download_image(url)  # ä¸²è¡Œç­‰å¾…
        images.append(image)
    return images
```

---

## å®‰å…¨ç¼–ç è§„èŒƒ

### è¾“å…¥éªŒè¯

```python
# âœ… ä¸¥æ ¼éªŒè¯ç”¨æˆ·è¾“å…¥
from pydantic import BaseModel, validator, Field

class BotConfigRequest(BaseModel):
    """Boté…ç½®è¯·æ±‚"""
    platform: str = Field(..., regex="^(discord|telegram|feishu)$")
    name: str = Field(..., min_length=1, max_length=50)
    webhook_url: Optional[str] = None
    
    @validator('webhook_url')
    def validate_webhook_url(cls, v, values):
        """éªŒè¯Webhook URL"""
        if values.get('platform') == 'discord' and v:
            if not v.startswith('https://discord.com/api/webhooks/'):
                raise ValueError('Discord Webhook URLæ ¼å¼ä¸æ­£ç¡®')
        return v


# âŒ ä¸éªŒè¯è¾“å…¥
@router.post("/bots")
async def add_bot(platform: str, name: str, config: str):
    """ç›´æ¥ä½¿ç”¨ç”¨æˆ·è¾“å…¥ï¼Œå±é™©ï¼"""
    db.add_bot_config(platform, name, config)
```

### SQLæ³¨å…¥é˜²æŠ¤

```python
# âœ… ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢
async def get_logs_by_status(status: str):
    """å®‰å…¨çš„æŸ¥è¯¢"""
    async with db.cursor() as cursor:
        await cursor.execute("""
            SELECT * FROM message_logs WHERE status = ?
        """, (status,))  # å‚æ•°åŒ–
        return await cursor.fetchall()


# âŒ å­—ç¬¦ä¸²æ‹¼æ¥ï¼ŒSQLæ³¨å…¥é£é™©
async def get_logs_by_status(status: str):
    """å±é™©ï¼"""
    async with db.cursor() as cursor:
        # å¦‚æœstatus = "success' OR '1'='1"ï¼Œä¼šè¿”å›æ‰€æœ‰è®°å½•
        await cursor.execute(f"""
            SELECT * FROM message_logs WHERE status = '{status}'
        """)  # å­—ç¬¦ä¸²æ‹¼æ¥
        return await cursor.fetchall()
```

### æ•æ„Ÿä¿¡æ¯ä¿æŠ¤

```python
# âœ… è„±æ•æ—¥å¿—
def log_account_info(account: dict):
    """è„±æ•åè®°å½•"""
    safe_account = {
        'id': account['id'],
        'email': mask_email(account['email']),  # u***@gmail.com
        'status': account['status']
        # ä¸è®°å½•cookieå’Œpassword
    }
    logger.info(f"è´¦å·ä¿¡æ¯: {safe_account}")


def mask_email(email: str) -> str:
    """é‚®ç®±è„±æ•"""
    if '@' not in email:
        return '***'
    
    local, domain = email.split('@')
    if len(local) <= 2:
        masked_local = '*' * len(local)
    else:
        masked_local = local[0] + '*' * (len(local) - 2) + local[-1]
    
    return f"{masked_local}@{domain}"


# âŒ ç›´æ¥è®°å½•æ•æ„Ÿä¿¡æ¯
def log_account_info(account: dict):
    """å±é™©ï¼šæ³„éœ²æ•æ„Ÿä¿¡æ¯"""
    logger.info(f"è´¦å·: {account}")  # åŒ…å«cookieå’Œpasswordï¼
```

---

## æµ‹è¯•è§„èŒƒ

### å•å…ƒæµ‹è¯•

```python
# âœ… å®Œæ•´çš„æµ‹è¯•ç”¨ä¾‹
import pytest
from backend.app.processors.formatter import formatter


class TestMessageFormatter:
    """æ¶ˆæ¯æ ¼å¼åŒ–å™¨æµ‹è¯•"""
    
    def test_kmarkdown_to_discord_bold(self):
        """æµ‹è¯•ç²—ä½“è½¬æ¢"""
        input_text = "**è¿™æ˜¯ç²—ä½“**"
        expected = "**è¿™æ˜¯ç²—ä½“**"
        result = formatter.kmarkdown_to_discord(input_text)
        assert result == expected
    
    def test_kmarkdown_to_discord_emoji(self):
        """æµ‹è¯•è¡¨æƒ…è½¬æ¢"""
        input_text = "(emj)smile(emj)"
        result = formatter.kmarkdown_to_discord(input_text)
        assert 'ğŸ˜Š' in result
    
    @pytest.mark.parametrize("input_text,expected", [
        ("**ç²—ä½“**", "**ç²—ä½“**"),
        ("*æ–œä½“*", "*æ–œä½“*"),
        ("`ä»£ç `", "`ä»£ç `"),
        ("æ··åˆ**ç²—ä½“**å’Œ*æ–œä½“*", "æ··åˆ**ç²—ä½“**å’Œ*æ–œä½“*")
    ])
    def test_mixed_formatting(self, input_text, expected):
        """æµ‹è¯•æ··åˆæ ¼å¼"""
        result = formatter.kmarkdown_to_discord(input_text)
        assert result == expected
```

### é›†æˆæµ‹è¯•

```python
# âœ… ç«¯åˆ°ç«¯æµ‹è¯•
@pytest.mark.asyncio
async def test_message_forwarding_e2e():
    """æµ‹è¯•å®Œæ•´çš„æ¶ˆæ¯è½¬å‘æµç¨‹"""
    
    # 1. å‡†å¤‡æ•°æ®
    test_message = {
        'message_id': 'test_e2e_001',
        'channel_id': 'test_channel',
        'content': 'E2Eæµ‹è¯•æ¶ˆæ¯'
    }
    
    # 2. å…¥é˜Ÿ
    await redis_queue.enqueue(test_message)
    
    # 3. ç­‰å¾…å¤„ç†
    await asyncio.sleep(5)
    
    # 4. éªŒè¯ç»“æœ
    logs, _ = await async_db.get_logs(limit=1)
    assert logs[0]['kook_message_id'] == 'test_e2e_001'
    assert logs[0]['status'] == 'success'
    
    # 5. æ¸…ç†
    await async_db.delete_log(logs[0]['id'])
```

---

## ä»£ç å®¡æŸ¥æ¸…å•

### æäº¤PRå‰è‡ªæŸ¥

#### åŠŸèƒ½å®Œæ•´æ€§
- [ ] å®ç°äº†è®¡åˆ’çš„æ‰€æœ‰åŠŸèƒ½
- [ ] é€šè¿‡äº†æ‰€æœ‰æµ‹è¯•ç”¨ä¾‹
- [ ] æ— æ˜æ˜¾Bug

#### ä»£ç è´¨é‡
- [ ] éµå¾ªä»£ç é£æ ¼è§„èŒƒ
- [ ] æ·»åŠ äº†å¿…è¦çš„æ³¨é‡Šå’Œæ–‡æ¡£å­—ç¬¦ä¸²
- [ ] ç±»å‹æ³¨è§£å®Œæ•´
- [ ] å˜é‡å‘½åæ¸…æ™°

#### æ€§èƒ½
- [ ] æ— æ˜æ˜¾æ€§èƒ½é—®é¢˜
- [ ] é¿å…äº†N+1æŸ¥è¯¢
- [ ] ä½¿ç”¨äº†é€‚å½“çš„å¹¶å‘
- [ ] å†…å­˜å ç”¨åˆç†

#### å®‰å…¨
- [ ] éªŒè¯äº†æ‰€æœ‰ç”¨æˆ·è¾“å…¥
- [ ] ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢
- [ ] æ•æ„Ÿä¿¡æ¯å·²è„±æ•
- [ ] æ— SQLæ³¨å…¥é£é™©

#### æµ‹è¯•
- [ ] æ·»åŠ äº†å•å…ƒæµ‹è¯•
- [ ] æµ‹è¯•è¦†ç›–ç‡ > 80%
- [ ] é›†æˆæµ‹è¯•é€šè¿‡

#### æ–‡æ¡£
- [ ] æ›´æ–°äº†ç›¸å…³æ–‡æ¡£
- [ ] æ›´æ–°äº†APIæ–‡æ¡£
- [ ] æ›´æ–°äº†æ£€æŸ¥æ¸…å•

---

## ğŸ“ æœ€ä½³å®è·µç¤ºä¾‹

### ç¤ºä¾‹1: å®Œæ•´çš„APIç«¯ç‚¹å®ç°

```python
"""
è´¦å·ç®¡ç†APIï¼ˆç¤ºèŒƒå®Œæ•´å®ç°ï¼‰
"""
from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel, validator, Field
from typing import List, Optional
from ..database_async import async_db
from ..utils.auth import verify_api_token
from ..utils.logger import logger
from ..utils.audit import audit_logger

router = APIRouter(
    prefix="/api/accounts",
    tags=["è´¦å·ç®¡ç†"],
    dependencies=[Depends(verify_api_token)]  # APIè®¤è¯
)


class AccountCreate(BaseModel):
    """åˆ›å»ºè´¦å·è¯·æ±‚"""
    email: str = Field(..., description="KOOKé‚®ç®±")
    cookie: Optional[str] = Field(None, description="Cookieï¼ˆJSONæ ¼å¼ï¼‰")
    password: Optional[str] = Field(None, min_length=6, description="å¯†ç ")
    
    @validator('email')
    def validate_email(cls, v):
        """éªŒè¯é‚®ç®±æ ¼å¼"""
        import re
        if not re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', v):
            raise ValueError('é‚®ç®±æ ¼å¼ä¸æ­£ç¡®')
        return v.lower()
    
    @validator('cookie')
    def validate_cookie(cls, v):
        """éªŒè¯Cookieæ ¼å¼"""
        if v:
            try:
                import json
                cookies = json.loads(v)
                if not isinstance(cookies, list):
                    raise ValueError('Cookieåº”ä¸ºJSONæ•°ç»„')
            except json.JSONDecodeError:
                raise ValueError('Cookieæ ¼å¼ä¸æ­£ç¡®')
        return v


class AccountResponse(BaseModel):
    """è´¦å·å“åº”"""
    id: int
    email: str
    status: str
    last_active: Optional[str]
    created_at: str


@router.post("/", response_model=AccountResponse, status_code=201)
async def create_account(
    account: AccountCreate,
    user_id: str = Depends(verify_api_token)
):
    """
    åˆ›å»ºè´¦å·
    
    - **email**: KOOKé‚®ç®±ï¼ˆå¿…éœ€ï¼‰
    - **cookie**: Cookieæ•°æ®ï¼ˆå¯é€‰ï¼‰
    - **password**: å¯†ç ï¼ˆå¯é€‰ï¼Œè‡³å°‘6ä½ï¼‰
    
    æ³¨æ„ï¼šcookieå’Œpasswordè‡³å°‘æä¾›ä¸€ä¸ª
    """
    try:
        # éªŒè¯
        if not account.cookie and not account.password:
            raise HTTPException(
                status_code=400,
                detail="cookieå’Œpasswordè‡³å°‘æä¾›ä¸€ä¸ª"
            )
        
        # åŠ å¯†å¯†ç 
        password_encrypted = None
        if account.password:
            from ..utils.crypto import crypto_manager
            password_encrypted = crypto_manager.encrypt(account.password)
        
        # åˆ›å»ºè´¦å·
        account_id = await async_db.add_account(
            email=account.email,
            password_encrypted=password_encrypted,
            cookie=account.cookie
        )
        
        # å®¡è®¡æ—¥å¿—
        await audit_logger.log(
            user_id=user_id,
            action='create_account',
            resource_type='account',
            resource_id=str(account_id),
            details=f"åˆ›å»ºè´¦å·: {account.email}"
        )
        
        # è¿”å›ç»“æœ
        account_data = await async_db.get_account(account_id)
        return AccountResponse(**account_data)
    
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    
    except Exception as e:
        logger.error(f"åˆ›å»ºè´¦å·å¤±è´¥: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="åˆ›å»ºè´¦å·å¤±è´¥")


@router.get("/", response_model=List[AccountResponse])
async def list_accounts(
    status: Optional[str] = None,
    limit: int = 100,
    offset: int = 0,
    user_id: str = Depends(verify_api_token)
):
    """
    è·å–è´¦å·åˆ—è¡¨
    
    - **status**: ç­›é€‰çŠ¶æ€ï¼ˆonline/offlineï¼‰
    - **limit**: æ¯é¡µæ•°é‡ï¼ˆé»˜è®¤100ï¼‰
    - **offset**: åç§»é‡ï¼ˆç”¨äºåˆ†é¡µï¼‰
    """
    try:
        accounts = await async_db.get_all_accounts()
        
        # ç­›é€‰
        if status:
            accounts = [a for a in accounts if a['status'] == status]
        
        # åˆ†é¡µ
        accounts = accounts[offset:offset+limit]
        
        return [AccountResponse(**account) for account in accounts]
    
    except Exception as e:
        logger.error(f"è·å–è´¦å·åˆ—è¡¨å¤±è´¥: {str(e)}")
        raise HTTPException(status_code=500, detail="è·å–è´¦å·åˆ—è¡¨å¤±è´¥")
```

---

### ç¤ºä¾‹2: å®Œæ•´çš„Vueç»„ä»¶å®ç°

```vue
<!-- ç¤ºèŒƒï¼šå®Œæ•´çš„Vueç»„ä»¶ -->
<template>
  <div class="account-card">
    <!-- åŠ è½½çŠ¶æ€ -->
    <el-skeleton v-if="loading" :rows="3" animated />

    <!-- æ­£å¸¸çŠ¶æ€ -->
    <el-card v-else shadow="hover" class="card">
      <template #header>
        <div class="card-header">
          <div class="account-info">
            <el-avatar :size="40" :src="account.avatar">
              {{ account.email.charAt(0).toUpperCase() }}
            </el-avatar>
            <div class="account-details">
              <h3>{{ account.email }}</h3>
              <el-tag :type="getStatusType(account.status)" size="small">
                {{ getStatusText(account.status) }}
              </el-tag>
            </div>
          </div>
          <el-dropdown @command="handleCommand">
            <el-icon><More /></el-icon>
            <template #dropdown>
              <el-dropdown-menu>
                <el-dropdown-item command="edit" :icon="Edit">
                  ç¼–è¾‘
                </el-dropdown-item>
                <el-dropdown-item command="reconnect" :icon="Refresh">
                  é‡æ–°è¿æ¥
                </el-dropdown-item>
                <el-dropdown-item command="delete" :icon="Delete" divided>
                  åˆ é™¤
                </el-dropdown-item>
              </el-dropdown-menu>
            </template>
          </el-dropdown>
        </div>
      </template>

      <!-- ç»Ÿè®¡ä¿¡æ¯ -->
      <el-descriptions :column="2" border size="small">
        <el-descriptions-item label="æœ€åæ´»è·ƒ">
          {{ formatTime(account.last_active) }}
        </el-descriptions-item>
        <el-descriptions-item label="ä»Šæ—¥è½¬å‘">
          {{ account.today_count || 0 }} æ¡
        </el-descriptions-item>
        <el-descriptions-item label="ç›‘å¬æœåŠ¡å™¨">
          {{ account.server_count || 0 }} ä¸ª
        </el-descriptions-item>
        <el-descriptions-item label="åˆ›å»ºæ—¶é—´">
          {{ formatTime(account.created_at) }}
        </el-descriptions-item>
      </el-descriptions>
    </el-card>

    <!-- é”™è¯¯çŠ¶æ€ -->
    <el-alert
      v-if="error"
      type="error"
      :title="error"
      :closable="false"
      show-icon
    />
  </div>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted } from 'vue'
import { ElMessage, ElMessageBox } from 'element-plus'
import { More, Edit, Refresh, Delete } from '@element-plus/icons-vue'
import { formatDistanceToNow } from 'date-fns'
import { zhCN } from 'date-fns/locale'
import api from '@/api'

// Props
const props = defineProps({
  accountId: {
    type: Number,
    required: true
  }
})

// Emits
const emit = defineEmits(['refresh', 'delete'])

// çŠ¶æ€
const account = ref(null)
const loading = ref(true)
const error = ref('')

// è®¡ç®—å±æ€§
const getStatusType = computed(() => (status) => {
  const typeMap = {
    online: 'success',
    offline: 'info',
    error: 'danger'
  }
  return typeMap[status] || 'info'
})

const getStatusText = computed(() => (status) => {
  const textMap = {
    online: 'åœ¨çº¿',
    offline: 'ç¦»çº¿',
    error: 'é”™è¯¯'
  }
  return textMap[status] || status
})

// æ–¹æ³•
const loadAccount = async () => {
  loading.value = true
  error.value = ''

  try {
    const data = await api.getAccount(props.accountId)
    account.value = data
  } catch (err) {
    error.value = 'åŠ è½½å¤±è´¥ï¼š' + err.message
    ElMessage.error(error.value)
  } finally {
    loading.value = false
  }
}

const formatTime = (timestamp) => {
  if (!timestamp) return 'ä»æœª'
  
  try {
    return formatDistanceToNow(new Date(timestamp), {
      addSuffix: true,
      locale: zhCN
    })
  } catch {
    return timestamp
  }
}

const handleCommand = async (command) => {
  switch (command) {
    case 'edit':
      await handleEdit()
      break
    case 'reconnect':
      await handleReconnect()
      break
    case 'delete':
      await handleDelete()
      break
  }
}

const handleEdit = async () => {
  // æ‰“å¼€ç¼–è¾‘å¯¹è¯æ¡†
  ElMessage.info('ç¼–è¾‘åŠŸèƒ½å¼€å‘ä¸­...')
}

const handleReconnect = async () => {
  try {
    await api.reconnectAccount(props.accountId)
    ElMessage.success('æ­£åœ¨é‡æ–°è¿æ¥...')
    await loadAccount()
  } catch (err) {
    ElMessage.error('é‡æ–°è¿æ¥å¤±è´¥ï¼š' + err.message)
  }
}

const handleDelete = async () => {
  try {
    await ElMessageBox.confirm(
      `ç¡®å®šè¦åˆ é™¤è´¦å· ${account.value.email} å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ï¼`,
      'ç¡®è®¤åˆ é™¤',
      {
        type: 'warning',
        confirmButtonText: 'ç¡®å®šåˆ é™¤',
        cancelButtonText: 'å–æ¶ˆ'
      }
    )

    await api.deleteAccount(props.accountId)
    ElMessage.success('è´¦å·å·²åˆ é™¤')
    emit('delete', props.accountId)

  } catch (err) {
    if (err !== 'cancel') {
      ElMessage.error('åˆ é™¤å¤±è´¥ï¼š' + err.message)
    }
  }
}

// ç”Ÿå‘½å‘¨æœŸ
onMounted(() => {
  loadAccount()

  // æ¯30ç§’è‡ªåŠ¨åˆ·æ–°
  const refreshInterval = setInterval(loadAccount, 30000)

  onUnmounted(() => {
    clearInterval(refreshInterval)
  })
})
</script>

<style scoped lang="scss">
.account-card {
  .card {
    transition: all 0.3s;

    &:hover {
      transform: translateY(-2px);
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;

      .account-info {
        display: flex;
        align-items: center;
        gap: 15px;

        .account-details {
          h3 {
            margin: 0 0 5px;
            font-size: 16px;
          }
        }
      }
    }
  }
}
</style>
```

---

## ğŸ“ æäº¤å‰æ£€æŸ¥æ¸…å•

### æ¯æ¬¡æäº¤å‰å¿…æŸ¥

- [ ] ä»£ç å·²æ ¼å¼åŒ–ï¼ˆPrettier/Blackï¼‰
- [ ] æ— Linté”™è¯¯ï¼ˆESLint/Pylintï¼‰
- [ ] æ·»åŠ /æ›´æ–°äº†æµ‹è¯•
- [ ] æµ‹è¯•å…¨éƒ¨é€šè¿‡
- [ ] æ–‡æ¡£å·²æ›´æ–°
- [ ] æäº¤ä¿¡æ¯æ¸…æ™°

### å¤§åŠŸèƒ½æäº¤å‰å¿…æŸ¥

- [ ] ä»£ç å®¡æŸ¥é€šè¿‡
- [ ] æ€§èƒ½æµ‹è¯•é€šè¿‡
- [ ] é›†æˆæµ‹è¯•é€šè¿‡
- [ ] ç”¨æˆ·æµ‹è¯•åé¦ˆè‰¯å¥½
- [ ] æ–‡æ¡£å®Œæ•´
- [ ] æ— å®‰å…¨éšæ‚£

---

<div align="center">

**éµå¾ªè§„èŒƒï¼Œå†™å‡ºä¼˜é›…çš„ä»£ç ï¼**

[è¿”å›æ€»ç´¢å¼•](./KOOKè½¬å‘ç³»ç»Ÿ_å®Œæ•´ä¼˜åŒ–å®æ–½æ‰‹å†Œ_æ€»ç´¢å¼•.md)

</div>
