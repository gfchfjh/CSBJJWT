# KOOK转发系统优化 - 代码规范和最佳实践

**版本**: v1.0  
**适用范围**: 所有优化开发

---

## 📋 目录

- [代码风格规范](#代码风格规范)
- [命名规范](#命名规范)
- [注释规范](#注释规范)
- [错误处理规范](#错误处理规范)
- [性能优化原则](#性能优化原则)
- [安全编码规范](#安全编码规范)

---

## 代码风格规范

### Python后端代码风格

#### 遵循PEP 8标准

```python
# ✅ 好的示例
class MessageWorker:
    """消息处理Worker（文档字符串必需）"""
    
    def __init__(self):
        self.is_running = False
        self._processed_messages = set()
    
    async def process_message(self, message: Dict[str, Any]) -> bool:
        """
        处理单条消息
        
        Args:
            message: 消息数据字典
            
        Returns:
            是否处理成功
            
        Raises:
            ValueError: 消息格式不正确
        """
        if not message.get('message_id'):
            raise ValueError("缺少message_id")
        
        # 业务逻辑...
        return True


# ❌ 坏的示例
class messageWorker:  # 类名应使用驼峰命名
    def process(self,message):  # 缺少类型注解和文档字符串
        if not message.get('message_id'):return False  # 应该分行
        return True
```

#### 类型注解

```python
# ✅ 必须添加类型注解
from typing import List, Dict, Any, Optional, Tuple

async def get_logs(
    limit: int = 100,
    offset: int = 0,
    status: Optional[str] = None
) -> Tuple[List[Dict[str, Any]], int]:
    """类型注解清晰"""
    pass


# ❌ 不要省略类型注解
async def get_logs(limit=100, offset=0, status=None):
    """类型不明确"""
    pass
```

#### 异步代码规范

```python
# ✅ 正确的异步调用
async def forward_message(message: dict) -> bool:
    # 使用await
    result = await api.send_message(message)
    
    # 并发处理
    results = await asyncio.gather(
        api.send_to_discord(message),
        api.send_to_telegram(message),
        return_exceptions=True
    )
    
    return all(results)


# ❌ 错误的异步调用
async def forward_message(message: dict) -> bool:
    # 忘记await
    result = api.send_message(message)  # 返回的是coroutine对象
    
    # 串行处理（应该并发）
    await api.send_to_discord(message)
    await api.send_to_telegram(message)
    
    return True
```

---

### Vue前端代码风格

#### 组件结构规范

```vue
<!-- ✅ 推荐的组件结构 -->
<template>
  <div class="component-name">
    <!-- 清晰的HTML结构 -->
  </div>
</template>

<script setup>
// 1. 导入
import { ref, computed, onMounted } from 'vue'
import { ElMessage } from 'element-plus'
import { Icon } from '@element-plus/icons-vue'

// 2. Props定义
const props = defineProps({
  modelValue: {
    type: String,
    required: true
  }
})

// 3. Emits定义
const emit = defineEmits(['update:modelValue', 'change'])

// 4. 响应式数据
const data = ref([])
const loading = ref(false)

// 5. 计算属性
const filteredData = computed(() => {
  return data.value.filter(item => item.active)
})

// 6. 方法
const handleClick = () => {
  // 业务逻辑
}

// 7. 生命周期
onMounted(() => {
  // 初始化逻辑
})
</script>

<style scoped lang="scss">
/* 使用SCSS */
.component-name {
  .child-element {
    // 嵌套样式
  }
}
</style>
```

#### Composition API规范

```vue
<script setup>
// ✅ 推荐：使用Composition API

import { ref, computed } from 'vue'

const count = ref(0)
const doubleCount = computed(() => count.value * 2)

const increment = () => {
  count.value++
}


// ❌ 不推荐：在优化代码中使用Options API
export default {
  data() {
    return {
      count: 0
    }
  },
  computed: {
    doubleCount() {
      return this.count * 2
    }
  }
}
</script>
```

---

## 命名规范

### 文件命名

```
前端文件:
✅ PascalCase: UserProfile.vue, AccountCard.vue
✅ kebab-case: user-profile.css, account-card.scss

后端文件:
✅ snake_case: user_manager.py, message_processor.py
✅ kebab-case: requirements-dev.txt, docker-compose.yml
```

### 变量命名

```python
# Python
✅ 变量: snake_case
user_name = "John"
message_count = 10

✅ 常量: UPPER_SNAKE_CASE
MAX_RETRY_COUNT = 3
DEFAULT_TIMEOUT = 30

✅ 类名: PascalCase
class MessageWorker:
    pass

✅ 私有变量: _leading_underscore
self._connection = None
```

```javascript
// JavaScript/Vue
✅ 变量: camelCase
const userName = 'John'
const messageCount = 10

✅ 常量: UPPER_SNAKE_CASE
const MAX_RETRY_COUNT = 3
const DEFAULT_TIMEOUT = 30

✅ 组件名: PascalCase
const UserProfile = defineComponent({})

✅ Props: camelCase
const props = defineProps({
  userName: String
})
```

### 函数命名

```python
# ✅ 动词开头，清晰表达意图
async def get_user_by_id(user_id: int) -> Optional[User]:
    """获取用户"""
    pass

async def create_bot_config(config: dict) -> int:
    """创建Bot配置"""
    pass

def is_valid_email(email: str) -> bool:
    """验证邮箱格式"""
    pass

# ❌ 命名不清晰
async def user(id):
    pass

async def handle(config):
    pass
```

---

## 注释规范

### 文档字符串

```python
# ✅ 完整的文档字符串
async def send_message(
    self,
    webhook_url: str,
    content: str,
    username: Optional[str] = None
) -> bool:
    """
    发送消息到Discord
    
    这个方法会自动处理：
    - 消息长度限制（2000字符）
    - 限流控制（5条/5秒）
    - 错误重试（最多3次）
    
    Args:
        webhook_url: Discord Webhook完整URL
        content: 消息内容（支持Markdown）
        username: 显示的用户名（可选，默认"KOOK消息转发"）
        
    Returns:
        True: 发送成功
        False: 发送失败
        
    Raises:
        ValueError: webhook_url格式不正确
        TimeoutError: 请求超时（>30秒）
        
    Example:
        >>> await forwarder.send_message(
        ...     webhook_url="https://discord.com/api/webhooks/123/abc",
        ...     content="Hello World",
        ...     username="Bot"
        ... )
        True
        
    Note:
        - 超长消息会自动分段发送
        - 图片URL会自动转换为Embed
        
    See Also:
        - send_with_attachment(): 发送带附件的消息
        - send_embed(): 发送Embed卡片
    """
    pass
```

### 行内注释

```python
# ✅ 好的注释：解释"为什么"

# 使用LRU缓存防止内存泄漏（最多10,000条）
self.processed_messages = LRUCache(max_size=10000)

# Discord限流：5条/5秒（官方限制）
await self.rate_limiter.acquire()

# 重试3次后放弃，避免无限循环
if retry_count >= 3:
    logger.error("重试次数已达上限")
    return False


# ❌ 坏的注释：重复代码内容

# 设置变量为10
max_retry = 10

# 如果count大于0
if count > 0:
    # 返回True
    return True
```

### TODO注释

```python
# ✅ 规范的TODO注释
# TODO(P0): 实现验证码自动识别 - 预计6小时 [@developer_name] [2025-10-26]
# TODO(P1): 优化图片压缩算法 - 性能提升50% [@developer_name] [2025-11-01]
# FIXME: Redis连接偶尔超时，需要添加重试机制
# HACK: 临时绕过KOOK的防盗链检查，需要更优雅的方案
# NOTE: 这个方法在v4.0会被废弃，建议使用new_method()

# ❌ 不规范的TODO
# TODO: fix this
# TODO: 优化
```

---

## 错误处理规范

### 异常捕获

```python
# ✅ 具体异常，清晰处理
async def download_image(url: str) -> bytes:
    """下载图片"""
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(url, timeout=30) as response:
                if response.status != 200:
                    raise HTTPException(
                        status_code=response.status,
                        detail=f"下载失败: HTTP {response.status}"
                    )
                return await response.read()
    
    except asyncio.TimeoutError:
        logger.error(f"下载超时: {url}")
        raise TimeoutError(f"图片下载超时（>30秒）: {url}")
    
    except aiohttp.ClientError as e:
        logger.error(f"网络错误: {str(e)}")
        raise ConnectionError(f"网络连接失败: {str(e)}")
    
    except Exception as e:
        logger.error(f"未知错误: {str(e)}", exc_info=True)
        raise RuntimeError(f"下载图片时发生未知错误: {str(e)}")


# ❌ 笼统捕获，信息不足
async def download_image(url: str) -> bytes:
    try:
        # ... 业务逻辑
        pass
    except Exception as e:
        print(f"Error: {e}")  # 不应该用print
        return None  # 不应该吞掉异常
```

### 错误日志

```python
# ✅ 结构化日志

logger.error(
    "消息转发失败",
    extra={
        'message_id': message['message_id'],
        'channel_id': message['channel_id'],
        'target_platform': 'discord',
        'error_type': 'rate_limit',
        'retry_count': 2
    }
)


# ❌ 简单字符串日志

logger.error("转发失败")  # 信息不足
```

---

## 性能优化原则

### 数据库查询优化

```python
# ✅ 使用索引
async def get_recent_logs(limit: int = 100):
    """利用created_at索引"""
    async with db.cursor() as cursor:
        await cursor.execute("""
            SELECT * FROM message_logs 
            WHERE created_at > datetime('now', '-1 day')
            ORDER BY created_at DESC 
            LIMIT ?
        """, (limit,))
        return await cursor.fetchall()


# ❌ 全表扫描
async def get_recent_logs(limit: int = 100):
    """性能差"""
    async with db.cursor() as cursor:
        await cursor.execute("""
            SELECT * FROM message_logs 
            WHERE strftime('%Y-%m-%d', created_at) = date('now')
        """)  # 函数调用无法使用索引
        return await cursor.fetchall()
```

### 避免N+1查询

```python
# ✅ 使用JOIN，一次查询
async def get_mappings_with_bots():
    """一次性获取映射和Bot配置"""
    async with db.cursor() as cursor:
        await cursor.execute("""
            SELECT 
                cm.*,
                bc.name as bot_name,
                bc.platform as bot_platform
            FROM channel_mappings cm
            JOIN bot_configs bc ON cm.target_bot_id = bc.id
            WHERE cm.enabled = 1
        """)
        return await cursor.fetchall()


# ❌ N+1查询
async def get_mappings_with_bots():
    """低效：每个映射查询一次Bot"""
    mappings = await get_all_mappings()
    
    for mapping in mappings:
        # 循环中查询数据库！
        bot = await get_bot_config(mapping['target_bot_id'])
        mapping['bot_name'] = bot['name']
    
    return mappings
```

### 并发优化

```python
# ✅ 并行处理
async def process_images(image_urls: List[str]) -> List[bytes]:
    """并行下载所有图片"""
    tasks = [download_image(url) for url in image_urls]
    results = await asyncio.gather(*tasks, return_exceptions=True)
    
    # 过滤异常
    images = [r for r in results if isinstance(r, bytes)]
    return images


# ❌ 串行处理
async def process_images(image_urls: List[str]) -> List[bytes]:
    """低效：逐个下载"""
    images = []
    for url in image_urls:
        image = await download_image(url)  # 串行等待
        images.append(image)
    return images
```

---

## 安全编码规范

### 输入验证

```python
# ✅ 严格验证用户输入
from pydantic import BaseModel, validator, Field

class BotConfigRequest(BaseModel):
    """Bot配置请求"""
    platform: str = Field(..., regex="^(discord|telegram|feishu)$")
    name: str = Field(..., min_length=1, max_length=50)
    webhook_url: Optional[str] = None
    
    @validator('webhook_url')
    def validate_webhook_url(cls, v, values):
        """验证Webhook URL"""
        if values.get('platform') == 'discord' and v:
            if not v.startswith('https://discord.com/api/webhooks/'):
                raise ValueError('Discord Webhook URL格式不正确')
        return v


# ❌ 不验证输入
@router.post("/bots")
async def add_bot(platform: str, name: str, config: str):
    """直接使用用户输入，危险！"""
    db.add_bot_config(platform, name, config)
```

### SQL注入防护

```python
# ✅ 使用参数化查询
async def get_logs_by_status(status: str):
    """安全的查询"""
    async with db.cursor() as cursor:
        await cursor.execute("""
            SELECT * FROM message_logs WHERE status = ?
        """, (status,))  # 参数化
        return await cursor.fetchall()


# ❌ 字符串拼接，SQL注入风险
async def get_logs_by_status(status: str):
    """危险！"""
    async with db.cursor() as cursor:
        # 如果status = "success' OR '1'='1"，会返回所有记录
        await cursor.execute(f"""
            SELECT * FROM message_logs WHERE status = '{status}'
        """)  # 字符串拼接
        return await cursor.fetchall()
```

### 敏感信息保护

```python
# ✅ 脱敏日志
def log_account_info(account: dict):
    """脱敏后记录"""
    safe_account = {
        'id': account['id'],
        'email': mask_email(account['email']),  # u***@gmail.com
        'status': account['status']
        # 不记录cookie和password
    }
    logger.info(f"账号信息: {safe_account}")


def mask_email(email: str) -> str:
    """邮箱脱敏"""
    if '@' not in email:
        return '***'
    
    local, domain = email.split('@')
    if len(local) <= 2:
        masked_local = '*' * len(local)
    else:
        masked_local = local[0] + '*' * (len(local) - 2) + local[-1]
    
    return f"{masked_local}@{domain}"


# ❌ 直接记录敏感信息
def log_account_info(account: dict):
    """危险：泄露敏感信息"""
    logger.info(f"账号: {account}")  # 包含cookie和password！
```

---

## 测试规范

### 单元测试

```python
# ✅ 完整的测试用例
import pytest
from backend.app.processors.formatter import formatter


class TestMessageFormatter:
    """消息格式化器测试"""
    
    def test_kmarkdown_to_discord_bold(self):
        """测试粗体转换"""
        input_text = "**这是粗体**"
        expected = "**这是粗体**"
        result = formatter.kmarkdown_to_discord(input_text)
        assert result == expected
    
    def test_kmarkdown_to_discord_emoji(self):
        """测试表情转换"""
        input_text = "(emj)smile(emj)"
        result = formatter.kmarkdown_to_discord(input_text)
        assert '😊' in result
    
    @pytest.mark.parametrize("input_text,expected", [
        ("**粗体**", "**粗体**"),
        ("*斜体*", "*斜体*"),
        ("`代码`", "`代码`"),
        ("混合**粗体**和*斜体*", "混合**粗体**和*斜体*")
    ])
    def test_mixed_formatting(self, input_text, expected):
        """测试混合格式"""
        result = formatter.kmarkdown_to_discord(input_text)
        assert result == expected
```

### 集成测试

```python
# ✅ 端到端测试
@pytest.mark.asyncio
async def test_message_forwarding_e2e():
    """测试完整的消息转发流程"""
    
    # 1. 准备数据
    test_message = {
        'message_id': 'test_e2e_001',
        'channel_id': 'test_channel',
        'content': 'E2E测试消息'
    }
    
    # 2. 入队
    await redis_queue.enqueue(test_message)
    
    # 3. 等待处理
    await asyncio.sleep(5)
    
    # 4. 验证结果
    logs, _ = await async_db.get_logs(limit=1)
    assert logs[0]['kook_message_id'] == 'test_e2e_001'
    assert logs[0]['status'] == 'success'
    
    # 5. 清理
    await async_db.delete_log(logs[0]['id'])
```

---

## 代码审查清单

### 提交PR前自查

#### 功能完整性
- [ ] 实现了计划的所有功能
- [ ] 通过了所有测试用例
- [ ] 无明显Bug

#### 代码质量
- [ ] 遵循代码风格规范
- [ ] 添加了必要的注释和文档字符串
- [ ] 类型注解完整
- [ ] 变量命名清晰

#### 性能
- [ ] 无明显性能问题
- [ ] 避免了N+1查询
- [ ] 使用了适当的并发
- [ ] 内存占用合理

#### 安全
- [ ] 验证了所有用户输入
- [ ] 使用参数化查询
- [ ] 敏感信息已脱敏
- [ ] 无SQL注入风险

#### 测试
- [ ] 添加了单元测试
- [ ] 测试覆盖率 > 80%
- [ ] 集成测试通过

#### 文档
- [ ] 更新了相关文档
- [ ] 更新了API文档
- [ ] 更新了检查清单

---

## 🎓 最佳实践示例

### 示例1: 完整的API端点实现

```python
"""
账号管理API（示范完整实现）
"""
from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel, validator, Field
from typing import List, Optional
from ..database_async import async_db
from ..utils.auth import verify_api_token
from ..utils.logger import logger
from ..utils.audit import audit_logger

router = APIRouter(
    prefix="/api/accounts",
    tags=["账号管理"],
    dependencies=[Depends(verify_api_token)]  # API认证
)


class AccountCreate(BaseModel):
    """创建账号请求"""
    email: str = Field(..., description="KOOK邮箱")
    cookie: Optional[str] = Field(None, description="Cookie（JSON格式）")
    password: Optional[str] = Field(None, min_length=6, description="密码")
    
    @validator('email')
    def validate_email(cls, v):
        """验证邮箱格式"""
        import re
        if not re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', v):
            raise ValueError('邮箱格式不正确')
        return v.lower()
    
    @validator('cookie')
    def validate_cookie(cls, v):
        """验证Cookie格式"""
        if v:
            try:
                import json
                cookies = json.loads(v)
                if not isinstance(cookies, list):
                    raise ValueError('Cookie应为JSON数组')
            except json.JSONDecodeError:
                raise ValueError('Cookie格式不正确')
        return v


class AccountResponse(BaseModel):
    """账号响应"""
    id: int
    email: str
    status: str
    last_active: Optional[str]
    created_at: str


@router.post("/", response_model=AccountResponse, status_code=201)
async def create_account(
    account: AccountCreate,
    user_id: str = Depends(verify_api_token)
):
    """
    创建账号
    
    - **email**: KOOK邮箱（必需）
    - **cookie**: Cookie数据（可选）
    - **password**: 密码（可选，至少6位）
    
    注意：cookie和password至少提供一个
    """
    try:
        # 验证
        if not account.cookie and not account.password:
            raise HTTPException(
                status_code=400,
                detail="cookie和password至少提供一个"
            )
        
        # 加密密码
        password_encrypted = None
        if account.password:
            from ..utils.crypto import crypto_manager
            password_encrypted = crypto_manager.encrypt(account.password)
        
        # 创建账号
        account_id = await async_db.add_account(
            email=account.email,
            password_encrypted=password_encrypted,
            cookie=account.cookie
        )
        
        # 审计日志
        await audit_logger.log(
            user_id=user_id,
            action='create_account',
            resource_type='account',
            resource_id=str(account_id),
            details=f"创建账号: {account.email}"
        )
        
        # 返回结果
        account_data = await async_db.get_account(account_id)
        return AccountResponse(**account_data)
    
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    
    except Exception as e:
        logger.error(f"创建账号失败: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="创建账号失败")


@router.get("/", response_model=List[AccountResponse])
async def list_accounts(
    status: Optional[str] = None,
    limit: int = 100,
    offset: int = 0,
    user_id: str = Depends(verify_api_token)
):
    """
    获取账号列表
    
    - **status**: 筛选状态（online/offline）
    - **limit**: 每页数量（默认100）
    - **offset**: 偏移量（用于分页）
    """
    try:
        accounts = await async_db.get_all_accounts()
        
        # 筛选
        if status:
            accounts = [a for a in accounts if a['status'] == status]
        
        # 分页
        accounts = accounts[offset:offset+limit]
        
        return [AccountResponse(**account) for account in accounts]
    
    except Exception as e:
        logger.error(f"获取账号列表失败: {str(e)}")
        raise HTTPException(status_code=500, detail="获取账号列表失败")
```

---

### 示例2: 完整的Vue组件实现

```vue
<!-- 示范：完整的Vue组件 -->
<template>
  <div class="account-card">
    <!-- 加载状态 -->
    <el-skeleton v-if="loading" :rows="3" animated />

    <!-- 正常状态 -->
    <el-card v-else shadow="hover" class="card">
      <template #header>
        <div class="card-header">
          <div class="account-info">
            <el-avatar :size="40" :src="account.avatar">
              {{ account.email.charAt(0).toUpperCase() }}
            </el-avatar>
            <div class="account-details">
              <h3>{{ account.email }}</h3>
              <el-tag :type="getStatusType(account.status)" size="small">
                {{ getStatusText(account.status) }}
              </el-tag>
            </div>
          </div>
          <el-dropdown @command="handleCommand">
            <el-icon><More /></el-icon>
            <template #dropdown>
              <el-dropdown-menu>
                <el-dropdown-item command="edit" :icon="Edit">
                  编辑
                </el-dropdown-item>
                <el-dropdown-item command="reconnect" :icon="Refresh">
                  重新连接
                </el-dropdown-item>
                <el-dropdown-item command="delete" :icon="Delete" divided>
                  删除
                </el-dropdown-item>
              </el-dropdown-menu>
            </template>
          </el-dropdown>
        </div>
      </template>

      <!-- 统计信息 -->
      <el-descriptions :column="2" border size="small">
        <el-descriptions-item label="最后活跃">
          {{ formatTime(account.last_active) }}
        </el-descriptions-item>
        <el-descriptions-item label="今日转发">
          {{ account.today_count || 0 }} 条
        </el-descriptions-item>
        <el-descriptions-item label="监听服务器">
          {{ account.server_count || 0 }} 个
        </el-descriptions-item>
        <el-descriptions-item label="创建时间">
          {{ formatTime(account.created_at) }}
        </el-descriptions-item>
      </el-descriptions>
    </el-card>

    <!-- 错误状态 -->
    <el-alert
      v-if="error"
      type="error"
      :title="error"
      :closable="false"
      show-icon
    />
  </div>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted } from 'vue'
import { ElMessage, ElMessageBox } from 'element-plus'
import { More, Edit, Refresh, Delete } from '@element-plus/icons-vue'
import { formatDistanceToNow } from 'date-fns'
import { zhCN } from 'date-fns/locale'
import api from '@/api'

// Props
const props = defineProps({
  accountId: {
    type: Number,
    required: true
  }
})

// Emits
const emit = defineEmits(['refresh', 'delete'])

// 状态
const account = ref(null)
const loading = ref(true)
const error = ref('')

// 计算属性
const getStatusType = computed(() => (status) => {
  const typeMap = {
    online: 'success',
    offline: 'info',
    error: 'danger'
  }
  return typeMap[status] || 'info'
})

const getStatusText = computed(() => (status) => {
  const textMap = {
    online: '在线',
    offline: '离线',
    error: '错误'
  }
  return textMap[status] || status
})

// 方法
const loadAccount = async () => {
  loading.value = true
  error.value = ''

  try {
    const data = await api.getAccount(props.accountId)
    account.value = data
  } catch (err) {
    error.value = '加载失败：' + err.message
    ElMessage.error(error.value)
  } finally {
    loading.value = false
  }
}

const formatTime = (timestamp) => {
  if (!timestamp) return '从未'
  
  try {
    return formatDistanceToNow(new Date(timestamp), {
      addSuffix: true,
      locale: zhCN
    })
  } catch {
    return timestamp
  }
}

const handleCommand = async (command) => {
  switch (command) {
    case 'edit':
      await handleEdit()
      break
    case 'reconnect':
      await handleReconnect()
      break
    case 'delete':
      await handleDelete()
      break
  }
}

const handleEdit = async () => {
  // 打开编辑对话框
  ElMessage.info('编辑功能开发中...')
}

const handleReconnect = async () => {
  try {
    await api.reconnectAccount(props.accountId)
    ElMessage.success('正在重新连接...')
    await loadAccount()
  } catch (err) {
    ElMessage.error('重新连接失败：' + err.message)
  }
}

const handleDelete = async () => {
  try {
    await ElMessageBox.confirm(
      `确定要删除账号 ${account.value.email} 吗？此操作不可恢复！`,
      '确认删除',
      {
        type: 'warning',
        confirmButtonText: '确定删除',
        cancelButtonText: '取消'
      }
    )

    await api.deleteAccount(props.accountId)
    ElMessage.success('账号已删除')
    emit('delete', props.accountId)

  } catch (err) {
    if (err !== 'cancel') {
      ElMessage.error('删除失败：' + err.message)
    }
  }
}

// 生命周期
onMounted(() => {
  loadAccount()

  // 每30秒自动刷新
  const refreshInterval = setInterval(loadAccount, 30000)

  onUnmounted(() => {
    clearInterval(refreshInterval)
  })
})
</script>

<style scoped lang="scss">
.account-card {
  .card {
    transition: all 0.3s;

    &:hover {
      transform: translateY(-2px);
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;

      .account-info {
        display: flex;
        align-items: center;
        gap: 15px;

        .account-details {
          h3 {
            margin: 0 0 5px;
            font-size: 16px;
          }
        }
      }
    }
  }
}
</style>
```

---

## 📝 提交前检查清单

### 每次提交前必查

- [ ] 代码已格式化（Prettier/Black）
- [ ] 无Lint错误（ESLint/Pylint）
- [ ] 添加/更新了测试
- [ ] 测试全部通过
- [ ] 文档已更新
- [ ] 提交信息清晰

### 大功能提交前必查

- [ ] 代码审查通过
- [ ] 性能测试通过
- [ ] 集成测试通过
- [ ] 用户测试反馈良好
- [ ] 文档完整
- [ ] 无安全隐患

---

<div align="center">

**遵循规范，写出优雅的代码！**

[返回总索引](./KOOK转发系统_完整优化实施手册_总索引.md)

</div>
