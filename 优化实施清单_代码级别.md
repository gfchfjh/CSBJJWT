# KOOK转发系统 - 代码级别优化实施清单

**配套主报告**: [深度优化分析报告](./KOOK转发系统深度优化分析报告.md)

---

## 🔧 P0优化 - 详细实施方案

### 1. 完善首次配置向导

#### 文件修改清单

**1.1 欢迎页组件** (`frontend/src/components/wizard/WizardStepWelcome.vue`)

```vue
<!-- 当前代码问题: 免责声明内容不完整 -->
<template>
  <div class="welcome-step">
    <h2>欢迎使用KOOK消息转发系统</h2>
    <!-- 缺少详细的免责声明 -->
  </div>
</template>

<!-- 修复方案: -->
<template>
  <div class="welcome-step">
    <div class="welcome-header">
      <el-icon :size="60" color="#409EFF"><Promotion /></el-icon>
      <h1>🎉 欢迎使用KOOK消息转发系统</h1>
      <p class="version">v{{ version }} Ultimate Edition</p>
    </div>

    <el-card class="disclaimer-card">
      <template #header>
        <div class="card-header">
          <el-icon color="#E6A23C"><Warning /></el-icon>
          <span>⚠️ 免责声明（请仔细阅读）</span>
        </div>
      </template>

      <el-scrollbar height="300px">
        <div class="disclaimer-content">
          <h3>请注意以下重要事项：</h3>
          
          <el-alert type="warning" :closable="false" style="margin: 10px 0">
            <strong>1. 技术实现风险</strong>
            <p>本软件通过浏览器自动化技术抓取KOOK消息，可能违反KOOK服务条款。</p>
          </el-alert>

          <el-alert type="error" :closable="false" style="margin: 10px 0">
            <strong>2. 账号安全风险</strong>
            <p>使用本软件可能导致您的KOOK账号被<b>警告、限制或永久封禁</b>。请确保：</p>
            <ul>
              <li>✅ 您拥有转发内容的合法权限</li>
              <li>✅ 您已获得服务器管理员授权</li>
              <li>✅ 您了解并接受账号被封禁的风险</li>
            </ul>
          </el-alert>

          <el-alert type="info" :closable="false" style="margin: 10px 0">
            <strong>3. 内容版权风险</strong>
            <p>转发的消息内容可能涉及版权保护。您应确保：</p>
            <ul>
              <li>✅ 遵守当地法律法规</li>
              <li>✅ 尊重原创作者权益</li>
              <li>✅ 不转发非法、侵权内容</li>
            </ul>
          </el-alert>

          <el-alert type="warning" :closable="false" style="margin: 10px 0">
            <strong>4. 隐私保护</strong>
            <p>本软件会存储您的登录凭证（Cookie）在本地。请确保：</p>
            <ul>
              <li>✅ 设备处于安全环境</li>
              <li>✅ 设置主密码保护</li>
              <li>✅ 定期更新密码</li>
            </ul>
          </el-alert>

          <el-alert type="error" :closable="false" style="margin: 10px 0">
            <strong>5. 免责声明</strong>
            <p>本软件<b>仅供学习交流使用</b>，开发者不承担任何法律责任，包括但不限于：</p>
            <ul>
              <li>❌ 账号被封禁的损失</li>
              <li>❌ 数据丢失或泄露</li>
              <li>❌ 法律纠纷和诉讼</li>
              <li>❌ 其他任何直接或间接损失</li>
            </ul>
          </el-alert>
        </div>
      </el-scrollbar>

      <div class="agreement">
        <el-checkbox v-model="agreed" size="large">
          <b>我已仔细阅读并完全理解以上条款，自愿承担所有风险</b>
        </el-checkbox>
      </div>
    </el-card>

    <div class="wizard-actions">
      <el-button @click="handleReject" :disabled="loading">
        拒绝并退出
      </el-button>
      <el-button 
        type="primary" 
        @click="handleAgree" 
        :disabled="!agreed || loading"
        :loading="loading"
      >
        同意并继续
      </el-button>
    </div>

    <!-- 预计耗时提示 -->
    <el-alert type="info" :closable="false" style="margin-top: 20px">
      <template #title>
        <el-icon><Clock /></el-icon>
        <span style="margin-left: 5px">配置向导预计耗时 3-5 分钟</span>
      </template>
    </el-alert>
  </div>
</template>

<script setup>
import { ref } from 'vue'
import { ElMessageBox } from 'element-plus'
import packageInfo from '../../../package.json'

const emit = defineEmits(['next', 'reject'])

const agreed = ref(false)
const loading = ref(false)
const version = packageInfo.version

const handleAgree = async () => {
  loading.value = true
  try {
    // 记录用户同意时间
    await api.recordAgreement({
      timestamp: new Date().toISOString(),
      version: version
    })
    emit('next')
  } catch (error) {
    ElMessage.error('记录协议失败，请重试')
  } finally {
    loading.value = false
  }
}

const handleReject = () => {
  emit('reject')
}
</script>
```

**1.2 登录步骤组件** (`frontend/src/components/wizard/WizardStepLogin.vue`)

```vue
<!-- 添加视频教程集成 -->
<template>
  <div class="login-step">
    <el-tabs v-model="loginMethod">
      <!-- 方法1: 账号密码 -->
      <el-tab-pane label="账号密码登录" name="password">
        <el-form :model="passwordForm" :rules="passwordRules" ref="passwordFormRef">
          <el-form-item label="KOOK邮箱" prop="email">
            <el-input 
              v-model="passwordForm.email" 
              placeholder="your@email.com"
              clearable
            />
          </el-form-item>

          <el-form-item label="密码" prop="password">
            <el-input 
              v-model="passwordForm.password" 
              type="password" 
              show-password
              placeholder="请输入密码"
            />
          </el-form-item>

          <el-alert type="info" :closable="false">
            首次登录可能需要输入验证码，请按提示操作
          </el-alert>
        </el-form>

        <!-- 新增: 视频教程按钮 -->
        <div class="tutorial-section">
          <el-divider>需要帮助？</el-divider>
          <el-button @click="showVideoTutorial('password-login')" text type="primary">
            <el-icon><VideoPlay /></el-icon>
            观看"账号密码登录"视频教程（2分钟）
          </el-button>
        </div>
      </el-tab-pane>

      <!-- 方法2: Cookie导入 -->
      <el-tab-pane label="Cookie导入" name="cookie">
        <CookieImportUltimate @success="handleCookieImported" />

        <!-- 新增: 详细教程 -->
        <div class="tutorial-section">
          <el-divider>Cookie获取教程</el-divider>
          <el-space wrap>
            <el-button @click="showVideoTutorial('cookie-chrome')" text type="primary">
              <el-icon><VideoPlay /></el-icon>
              Chrome浏览器（3分钟）
            </el-button>
            <el-button @click="showVideoTutorial('cookie-firefox')" text type="primary">
              <el-icon><VideoPlay /></el-icon>
              Firefox浏览器（3分钟）
            </el-button>
            <el-button @click="showVideoTutorial('cookie-extension')" text type="primary">
              <el-icon><VideoPlay /></el-icon>
              使用浏览器扩展（1分钟）
            </el-button>
          </el-space>

          <!-- 新增: 图文教程链接 -->
          <el-card style="margin-top: 15px">
            <template #header>📖 图文教程</template>
            <el-link type="primary" @click="openDocumentation('cookie-chrome')">
              Chrome浏览器Cookie获取详细步骤 →
            </el-link>
            <br/>
            <el-link type="primary" @click="openDocumentation('cookie-extension')">
              安装和使用Cookie Editor扩展 →
            </el-link>
          </el-card>
        </div>
      </el-tab-pane>
    </el-tabs>

    <!-- 视频教程对话框 -->
    <el-dialog 
      v-model="videoDialogVisible" 
      :title="currentVideoTitle"
      width="70%"
      @close="handleVideoClose"
    >
      <VideoTutorial 
        :video-id="currentVideoId" 
        :autoplay="true"
      />
      
      <template #footer>
        <el-button @click="videoDialogVisible = false">关闭</el-button>
        <el-button type="primary" @click="replayVideo">重新播放</el-button>
      </template>
    </el-dialog>

    <!-- 操作按钮 -->
    <div class="wizard-actions">
      <el-button @click="emit('prev')">上一步</el-button>
      <el-button 
        type="primary" 
        @click="handleLogin"
        :loading="logging"
        :disabled="!canProceed"
      >
        {{ logging ? '登录中...' : '登录并继续' }}
      </el-button>
    </div>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue'
import { ElMessage } from 'element-plus'
import api from '@/api'
import CookieImportUltimate from '../CookieImportUltimate.vue'
import VideoTutorial from '../VideoTutorial.vue'

const emit = defineEmits(['next', 'prev', 'openVideo'])

const loginMethod = ref('password')
const logging = ref(false)

// 密码登录表单
const passwordForm = ref({
  email: '',
  password: ''
})

const passwordRules = {
  email: [
    { required: true, message: '请输入邮箱', trigger: 'blur' },
    { type: 'email', message: '请输入有效的邮箱', trigger: 'blur' }
  ],
  password: [
    { required: true, message: '请输入密码', trigger: 'blur' },
    { min: 6, message: '密码至少6位', trigger: 'blur' }
  ]
}

// 视频教程
const videoDialogVisible = ref(false)
const currentVideoId = ref('')
const currentVideoTitle = ref('')

const videoMap = {
  'password-login': { title: '账号密码登录教程', id: 'tutorial_password_login' },
  'cookie-chrome': { title: 'Chrome获取Cookie教程', id: 'tutorial_cookie_chrome' },
  'cookie-firefox': { title: 'Firefox获取Cookie教程', id: 'tutorial_cookie_firefox' },
  'cookie-extension': { title: '浏览器扩展使用教程', id: 'tutorial_cookie_extension' }
}

const showVideoTutorial = (type) => {
  const video = videoMap[type]
  if (video) {
    currentVideoId.value = video.id
    currentVideoTitle.value = video.title
    videoDialogVisible.value = true
  }
}

const replayVideo = () => {
  // 触发VideoTutorial组件重新播放
  videoDialogVisible.value = false
  setTimeout(() => {
    videoDialogVisible.value = true
  }, 100)
}

const openDocumentation = (type) => {
  // 打开文档页面
  window.open(`/docs/${type}.html`, '_blank')
}

const handleLogin = async () => {
  if (loginMethod.value === 'password') {
    // 验证表单
    await passwordFormRef.value.validate()
    
    logging.value = true
    try {
      const result = await api.loginAccount(passwordForm.value)
      if (result.success) {
        ElMessage.success('登录成功！')
        emit('next')
      } else {
        ElMessage.error(result.message || '登录失败')
      }
    } catch (error) {
      ElMessage.error('登录异常: ' + error.message)
    } finally {
      logging.value = false
    }
  }
}

const handleCookieImported = () => {
  ElMessage.success('Cookie导入成功！')
  emit('next')
}

const canProceed = computed(() => {
  if (loginMethod.value === 'password') {
    return passwordForm.value.email && passwordForm.value.password
  }
  return false // Cookie导入会直接触发next
})
</script>
```

---

### 2. 完善一键安装包

#### 后端打包配置 (`backend/build_backend.spec`)

```python
# -*- mode: python ; coding: utf-8 -*-
"""
PyInstaller打包配置 - 完整版
"""

import os
import sys
from pathlib import Path

# 项目根目录
ROOT_DIR = Path(__file__).parent.parent

# 收集所有依赖
block_cipher = None

# 需要包含的数据文件
datas = [
    # Redis服务器（根据平台选择）
    (str(ROOT_DIR / 'redis' / 'redis-server.exe'), 'redis') if sys.platform == 'win32' 
    else (str(ROOT_DIR / 'redis' / 'redis-server'), 'redis'),
    
    # Redis配置文件
    (str(ROOT_DIR / 'redis' / 'redis.conf'), 'redis'),
    
    # 数据库初始化脚本
    (str(ROOT_DIR / 'backend' / 'app' / 'database.py'), 'app'),
    
    # 选择器配置
    (str(ROOT_DIR / 'backend' / 'data' / 'selectors.yaml'), 'data'),
    
    # 文档
    (str(ROOT_DIR / 'docs'), 'docs'),
]

# 需要包含的二进制文件
binaries = []

# 隐藏导入
hiddenimports = [
    'playwright',
    'playwright._impl',
    'playwright.async_api',
    'aiosqlite',
    'aiofiles',
    'aioredis',
    'aiosmtplib',
    'cryptography',
    'bcrypt',
    'orjson',
    'uvicorn',
    'uvicorn.lifespan.on',
    'uvicorn.lifespan.off',
    'uvicorn.protocols.websockets.auto',
    'uvicorn.protocols.http.auto',
    'uvicorn.loops.auto',
    'fastapi',
    'pydantic',
    'discord_webhook',
    'telegram',
    'lark_oapi',
]

a = Analysis(
    [str(ROOT_DIR / 'backend' / 'app' / 'main.py')],
    pathex=[str(ROOT_DIR / 'backend')],
    binaries=binaries,
    datas=datas,
    hiddenimports=hiddenimports,
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
    noarchive=False,
)

pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=True,
    name='kook-forwarder-backend',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    console=True,  # 生产环境改为False
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
)

coll = COLLECT(
    exe,
    a.binaries,
    a.zipfiles,
    a.datas,
    strip=False,
    upx=True,
    upx_exclude=[],
    name='kook-forwarder-backend',
)
```

#### 前端Electron Builder配置 (`frontend/package.json` - build部分)

```json
{
  "build": {
    "appId": "com.kookforwarder.app",
    "productName": "KOOK消息转发系统",
    "copyright": "Copyright © 2025 KOOK Forwarder Team",
    "directories": {
      "output": "dist-electron",
      "buildResources": "build-resources"
    },
    "files": [
      "dist/**/*",
      "electron/**/*",
      "!node_modules/**/*",
      {
        "from": "../backend/dist/kook-forwarder-backend",
        "to": "resources/backend",
        "filter": ["**/*"]
      }
    ],
    "extraResources": [
      {
        "from": "../redis",
        "to": "redis",
        "filter": ["redis-server*", "redis.conf"]
      },
      {
        "from": "../docs",
        "to": "docs",
        "filter": ["**/*"]
      },
      {
        "from": "public/icon.png",
        "to": "icon.png"
      }
    ],
    "win": {
      "target": [
        {
          "target": "nsis",
          "arch": ["x64"]
        },
        {
          "target": "portable",
          "arch": ["x64"]
        }
      ],
      "icon": "build/icon.ico",
      "requestedExecutionLevel": "asInvoker",
      "artifactName": "${productName}-${version}-Windows-${arch}.${ext}"
    },
    "nsis": {
      "oneClick": false,
      "allowToChangeInstallationDirectory": true,
      "allowElevation": true,
      "installerIcon": "build/icon.ico",
      "uninstallerIcon": "build/icon.ico",
      "installerHeaderIcon": "build/icon.ico",
      "createDesktopShortcut": true,
      "createStartMenuShortcut": true,
      "shortcutName": "KOOK消息转发系统",
      "include": "build/installer.nsh",
      "deleteAppDataOnUninstall": false
    },
    "mac": {
      "target": [
        {
          "target": "dmg",
          "arch": ["x64", "arm64"]
        }
      ],
      "icon": "build/icon.icns",
      "category": "public.app-category.utilities",
      "hardenedRuntime": true,
      "gatekeeperAssess": false,
      "entitlements": "build/entitlements.mac.plist",
      "entitlementsInherit": "build/entitlements.mac.plist",
      "artifactName": "${productName}-${version}-macOS-${arch}.${ext}"
    },
    "dmg": {
      "contents": [
        {
          "x": 130,
          "y": 220
        },
        {
          "x": 410,
          "y": 220,
          "type": "link",
          "path": "/Applications"
        }
      ],
      "window": {
        "width": 540,
        "height": 380
      }
    },
    "linux": {
      "target": [
        {
          "target": "AppImage",
          "arch": ["x64"]
        },
        {
          "target": "deb",
          "arch": ["x64"]
        }
      ],
      "icon": "build/icons",
      "category": "Utility",
      "maintainer": "KOOK Forwarder Team",
      "artifactName": "${productName}-${version}-Linux-${arch}.${ext}"
    },
    "publish": null,
    "compression": "maximum",
    "asar": true,
    "asarUnpack": [
      "resources/backend/**/*",
      "resources/redis/**/*"
    ]
  }
}
```

#### 构建脚本 (`build/build_complete.sh`)

```bash
#!/bin/bash
# 完整构建脚本 - 生成所有平台安装包

set -e  # 遇到错误立即退出

echo "================================"
echo "KOOK消息转发系统 - 完整构建"
echo "================================"

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# 项目根目录
PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$PROJECT_ROOT"

# 1. 检查环境
echo -e "${YELLOW}[1/7] 检查构建环境...${NC}"
python --version || { echo -e "${RED}错误: Python未安装${NC}"; exit 1; }
node --version || { echo -e "${RED}错误: Node.js未安装${NC}"; exit 1; }
npm --version || { echo -e "${RED}错误: npm未安装${NC}"; exit 1; }
echo -e "${GREEN}✓ 环境检查通过${NC}"

# 2. 安装后端依赖
echo -e "${YELLOW}[2/7] 安装后端依赖...${NC}"
cd backend
pip install -r requirements.txt
pip install pyinstaller
echo -e "${GREEN}✓ 后端依赖安装完成${NC}"

# 3. 下载Playwright浏览器
echo -e "${YELLOW}[3/7] 下载Playwright浏览器...${NC}"
playwright install chromium --with-deps
echo -e "${GREEN}✓ Chromium下载完成${NC}"

# 4. 打包后端
echo -e "${YELLOW}[4/7] 打包后端应用...${NC}"
pyinstaller build_backend.spec --clean --noconfirm
if [ ! -f "dist/kook-forwarder-backend/kook-forwarder-backend" ] && [ ! -f "dist/kook-forwarder-backend/kook-forwarder-backend.exe" ]; then
    echo -e "${RED}错误: 后端打包失败${NC}"
    exit 1
fi
echo -e "${GREEN}✓ 后端打包完成${NC}"

# 5. 安装前端依赖
echo -e "${YELLOW}[5/7] 安装前端依赖...${NC}"
cd ../frontend
npm install
echo -e "${GREEN}✓ 前端依赖安装完成${NC}"

# 6. 构建前端
echo -e "${YELLOW}[6/7] 构建前端应用...${NC}"
npm run build
echo -e "${GREEN}✓ 前端构建完成${NC}"

# 7. 打包Electron应用
echo -e "${YELLOW}[7/7] 打包Electron应用...${NC}"

# 检测操作系统
OS="$(uname -s)"
case "${OS}" in
    Linux*)
        echo "打包Linux版本..."
        npm run electron:build:linux
        ;;
    Darwin*)
        echo "打包macOS版本..."
        npm run electron:build:mac
        ;;
    MINGW*|MSYS*|CYGWIN*)
        echo "打包Windows版本..."
        npm run electron:build:win
        ;;
    *)
        echo "打包所有平台版本..."
        npm run electron:build
        ;;
esac

echo -e "${GREEN}✓ Electron打包完成${NC}"

# 8. 显示结果
echo ""
echo "================================"
echo -e "${GREEN}构建完成！${NC}"
echo "================================"
echo "安装包位置: frontend/dist-electron/"
ls -lh frontend/dist-electron/*.{exe,dmg,AppImage,deb} 2>/dev/null || echo "未找到安装包文件"

# 9. 生成校验和
echo ""
echo -e "${YELLOW}生成SHA256校验和...${NC}"
cd dist-electron
for file in *.{exe,dmg,AppImage,deb}; do
    if [ -f "$file" ]; then
        sha256sum "$file" > "$file.sha256"
        echo -e "${GREEN}✓ $file${NC}"
    fi
done

echo ""
echo -e "${GREEN}所有任务完成！${NC}"
```

---

### 3. Cookie导入增强

#### Cookie解析器 (`backend/app/utils/cookie_parser.py`)

```python
"""
Cookie解析器 - 支持多种格式
"""
import json
import re
from typing import List, Dict, Any, Optional
from datetime import datetime


class CookieParser:
    """统一的Cookie解析器"""
    
    @staticmethod
    def parse(cookie_data: str) -> List[Dict[str, Any]]:
        """
        自动识别并解析Cookie格式
        
        支持格式:
        1. JSON数组: [{"name": "key", "value": "val", ...}]
        2. Netscape格式: # Netscape HTTP Cookie File
        3. Chrome DevTools格式: name=value; name2=value2
        4. EditThisCookie格式: {"name": "key", "value": "val", ...}
        """
        cookie_data = cookie_data.strip()
        
        # 格式1: JSON数组
        if cookie_data.startswith('['):
            return CookieParser._parse_json_array(cookie_data)
        
        # 格式2: Netscape格式
        if '# Netscape HTTP Cookie File' in cookie_data or '\t' in cookie_data:
            return CookieParser._parse_netscape(cookie_data)
        
        # 格式3: Chrome DevTools格式
        if '=' in cookie_data and (';' in cookie_data or '\n' not in cookie_data):
            return CookieParser._parse_key_value_pairs(cookie_data)
        
        # 格式4: EditThisCookie JSON对象
        if cookie_data.startswith('{'):
            return CookieParser._parse_edit_this_cookie(cookie_data)
        
        raise ValueError(f"无法识别的Cookie格式。请确保使用以下格式之一:\\n"
                       f"1. JSON数组 [{{...}}]\\n"
                       f"2. Netscape格式\\n"
                       f"3. name=value; name2=value2\\n"
                       f"4. EditThisCookie JSON")
    
    @staticmethod
    def _parse_json_array(data: str) -> List[Dict]:
        """解析JSON数组格式"""
        try:
            cookies = json.loads(data)
            if not isinstance(cookies, list):
                raise ValueError("JSON格式错误：应该是数组")
            
            # 标准化字段
            standardized = []
            for cookie in cookies:
                standardized.append(CookieParser._standardize_cookie(cookie))
            
            return standardized
        except json.JSONDecodeError as e:
            raise ValueError(f"JSON解析失败: {str(e)}")
    
    @staticmethod
    def _parse_netscape(data: str) -> List[Dict]:
        """
        解析Netscape格式
        格式: domain\tflag\tpath\tsecure\texpiration\tname\tvalue
        """
        cookies = []
        for line in data.split('\n'):
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            
            parts = line.split('\t')
            if len(parts) < 7:
                continue
            
            domain, flag, path, secure, expiration, name, value = parts[:7]
            
            cookie = {
                'name': name,
                'value': value,
                'domain': domain,
                'path': path,
                'secure': secure.lower() == 'true',
                'httpOnly': flag.lower() == 'true',
                'sameSite': 'Lax'
            }
            
            # 转换过期时间
            try:
                exp_timestamp = int(expiration)
                if exp_timestamp > 0:
                    cookie['expires'] = exp_timestamp
            except:
                pass
            
            cookies.append(cookie)
        
        return cookies
    
    @staticmethod
    def _parse_key_value_pairs(data: str) -> List[Dict]:
        """
        解析键值对格式
        格式: name=value; name2=value2
        """
        cookies = []
        
        # 分割多个Cookie
        pairs = []
        if ';' in data:
            pairs = [p.strip() for p in data.split(';')]
        else:
            pairs = [line.strip() for line in data.split('\n') if '=' in line]
        
        for pair in pairs:
            if '=' not in pair:
                continue
            
            name, value = pair.split('=', 1)
            cookies.append({
                'name': name.strip(),
                'value': value.strip(),
                'domain': '.kookapp.cn',  # 默认域名
                'path': '/',
                'secure': True,
                'httpOnly': True,
                'sameSite': 'Lax'
            })
        
        return cookies
    
    @staticmethod
    def _parse_edit_this_cookie(data: str) -> List[Dict]:
        """解析EditThisCookie导出的JSON对象"""
        try:
            cookie = json.loads(data)
            if isinstance(cookie, dict):
                # 单个Cookie对象
                return [CookieParser._standardize_cookie(cookie)]
            elif isinstance(cookie, list):
                # 多个Cookie
                return [CookieParser._standardize_cookie(c) for c in cookie]
            else:
                raise ValueError("EditThisCookie格式错误")
        except json.JSONDecodeError as e:
            raise ValueError(f"JSON解析失败: {str(e)}")
    
    @staticmethod
    def _standardize_cookie(cookie: Dict) -> Dict:
        """标准化Cookie字段"""
        # 确保必需字段存在
        required_fields = ['name', 'value']
        for field in required_fields:
            if field not in cookie:
                raise ValueError(f"Cookie缺少必需字段: {field}")
        
        # 标准化字段名（兼容不同格式）
        standardized = {
            'name': cookie.get('name'),
            'value': cookie.get('value'),
            'domain': cookie.get('domain') or cookie.get('Domain') or '.kookapp.cn',
            'path': cookie.get('path') or cookie.get('Path') or '/',
            'secure': cookie.get('secure') or cookie.get('Secure') or True,
            'httpOnly': cookie.get('httpOnly') or cookie.get('HttpOnly') or False,
            'sameSite': cookie.get('sameSite') or cookie.get('SameSite') or 'Lax'
        }
        
        # 可选字段
        if 'expires' in cookie or 'Expires' in cookie:
            expires = cookie.get('expires') or cookie.get('Expires')
            if isinstance(expires, str):
                # 尝试解析日期字符串
                try:
                    dt = datetime.fromisoformat(expires)
                    standardized['expires'] = int(dt.timestamp())
                except:
                    pass
            elif isinstance(expires, (int, float)):
                standardized['expires'] = int(expires)
        
        return standardized
    
    @staticmethod
    def validate(cookies: List[Dict]) -> bool:
        """验证Cookie列表的有效性"""
        if not cookies:
            return False
        
        # 检查KOOK必需的Cookie
        required_cookies = ['token', 'user_id']  # KOOK必需的Cookie名称
        cookie_names = [c['name'] for c in cookies]
        
        for required in required_cookies:
            if required not in cookie_names:
                print(f"警告: 缺少必需Cookie: {required}")
                # 不要因为缺少某个Cookie就拒绝，因为KOOK的Cookie名称可能变化
        
        return True
    
    @staticmethod
    def to_playwright_format(cookies: List[Dict]) -> List[Dict]:
        """转换为Playwright可用的格式"""
        playwright_cookies = []
        
        for cookie in cookies:
            pw_cookie = {
                'name': cookie['name'],
                'value': cookie['value'],
                'domain': cookie.get('domain', '.kookapp.cn'),
                'path': cookie.get('path', '/'),
            }
            
            # 可选字段
            if 'expires' in cookie:
                pw_cookie['expires'] = cookie['expires']
            if 'httpOnly' in cookie:
                pw_cookie['httpOnly'] = cookie['httpOnly']
            if 'secure' in cookie:
                pw_cookie['secure'] = cookie['secure']
            if 'sameSite' in cookie:
                pw_cookie['sameSite'] = cookie['sameSite']
            
            playwright_cookies.append(pw_cookie)
        
        return playwright_cookies


# 全局实例
cookie_parser = CookieParser()
```

#### Cookie导入API (`backend/app/api/cookie_import.py` - 增强版)

```python
"""
Cookie导入API - 增强版
"""
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import Optional
from ..utils.cookie_parser import cookie_parser
from ..utils.logger import logger
from ..database import db
from ..kook.scraper import KookScraper

router = APIRouter(prefix="/api/cookie", tags=["Cookie导入"])


class CookieImportRequest(BaseModel):
    """Cookie导入请求"""
    cookie_data: str
    account_email: Optional[str] = None  # 可选: 账号邮箱（用于标识）
    auto_test: bool = True  # 是否自动测试Cookie有效性


class CookieValidationResponse(BaseModel):
    """Cookie验证响应"""
    valid: bool
    message: str
    cookie_count: int
    missing_cookies: list[str] = []
    warnings: list[str] = []


@router.post("/import")
async def import_cookie(request: CookieImportRequest):
    """
    导入Cookie
    
    支持多种格式:
    - JSON数组
    - Netscape格式
    - Chrome DevTools格式
    - EditThisCookie格式
    """
    try:
        # 1. 解析Cookie
        logger.info(f"开始解析Cookie，数据长度: {len(request.cookie_data)}")
        cookies = cookie_parser.parse(request.cookie_data)
        logger.info(f"解析成功，共{len(cookies)}个Cookie")
        
        # 2. 验证Cookie
        if not cookie_parser.validate(cookies):
            return {
                "success": False,
                "message": "Cookie验证失败：缺少必需的认证Cookie"
            }
        
        # 3. 可选: 测试Cookie有效性
        if request.auto_test:
            logger.info("开始测试Cookie有效性...")
            is_valid, test_message = await test_cookie_validity(cookies)
            
            if not is_valid:
                return {
                    "success": False,
                    "message": f"Cookie测试失败: {test_message}",
                    "details": {
                        "cookie_count": len(cookies),
                        "test_result": test_message
                    }
                }
        
        # 4. 保存Cookie到数据库
        account_id = db.add_account(
            email=request.account_email or "cookie_import_" + str(len(cookies)),
            cookie=json.dumps(cookies),
            password_encrypted=None
        )
        
        logger.info(f"Cookie导入成功，账号ID: {account_id}")
        
        return {
            "success": True,
            "message": "Cookie导入成功！",
            "data": {
                "account_id": account_id,
                "cookie_count": len(cookies),
                "test_passed": request.auto_test
            }
        }
        
    except ValueError as e:
        logger.error(f"Cookie解析失败: {str(e)}")
        raise HTTPException(status_code=400, detail=str(e))
    
    except Exception as e:
        logger.error(f"Cookie导入失败: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="Cookie导入失败")


@router.post("/validate")
async def validate_cookie(request: CookieImportRequest) -> CookieValidationResponse:
    """
    验证Cookie（不保存）
    
    用于用户导入前预检查
    """
    try:
        # 解析Cookie
        cookies = cookie_parser.parse(request.cookie_data)
        
        # 验证
        is_valid = cookie_parser.validate(cookies)
        
        # 检查缺失的Cookie
        required_cookies = ['token', 'user_id']
        cookie_names = [c['name'] for c in cookies]
        missing = [c for c in required_cookies if c not in cookie_names]
        
        # 生成警告
        warnings = []
        if missing:
            warnings.append(f"缺少以下Cookie: {', '.join(missing)}")
        
        # 检查过期
        import time
        now = time.time()
        for cookie in cookies:
            if 'expires' in cookie and cookie['expires'] < now:
                warnings.append(f"Cookie '{cookie['name']}' 已过期")
        
        return CookieValidationResponse(
            valid=is_valid and len(missing) == 0,
            message="Cookie验证通过" if is_valid else "Cookie验证失败",
            cookie_count=len(cookies),
            missing_cookies=missing,
            warnings=warnings
        )
        
    except ValueError as e:
        return CookieValidationResponse(
            valid=False,
            message=str(e),
            cookie_count=0
        )


async def test_cookie_validity(cookies: list[dict]) -> tuple[bool, str]:
    """
    测试Cookie有效性
    
    Returns:
        (是否有效, 测试消息)
    """
    try:
        # 创建临时Scraper测试
        scraper = KookScraper(account_id=-1)  # 临时ID
        
        # 尝试启动并检查登录状态
        success = await scraper.start(cookie=json.dumps(cookies))
        
        if success:
            # 尝试获取服务器列表验证
            servers = await scraper.get_servers()
            await scraper.stop()
            
            if servers:
                return True, f"Cookie有效，检测到{len(servers)}个服务器"
            else:
                return False, "Cookie可能已过期，无法获取服务器列表"
        else:
            return False, "Cookie无效或已过期"
            
    except Exception as e:
        logger.error(f"Cookie测试异常: {str(e)}")
        return False, f"测试异常: {str(e)}"


@router.get("/formats")
async def get_supported_formats():
    """获取支持的Cookie格式说明"""
    return {
        "formats": [
            {
                "name": "JSON数组",
                "description": "Chrome DevTools导出的JSON格式",
                "example": '[{"name":"token","value":"xxx","domain":".kookapp.cn"}]',
                "recommended": True
            },
            {
                "name": "Netscape格式",
                "description": "Firefox导出的Netscape HTTP Cookie格式",
                "example": ".kookapp.cn\\tTRUE\\t/\\tTRUE\\t0\\ttoken\\txxx",
                "recommended": False
            },
            {
                "name": "键值对格式",
                "description": "简单的name=value格式",
                "example": "token=xxx; user_id=123",
                "recommended": False
            },
            {
                "name": "EditThisCookie",
                "description": "EditThisCookie扩展导出的格式",
                "example": '{"name":"token","value":"xxx"}',
                "recommended": True
            }
        ],
        "tutorials": [
            {
                "browser": "Chrome",
                "video_id": "cookie-chrome",
                "doc_url": "/docs/cookie-chrome.html"
            },
            {
                "browser": "Firefox",
                "video_id": "cookie-firefox",
                "doc_url": "/docs/cookie-firefox.html"
            }
        ]
    }
```

---

## 📝 实施检查清单

### P0优化完成标准

#### ✅ 首次配置向导

- [ ] 免责声明内容完整（5项风险提示）
- [ ] 视频教程集成（5个教程）
- [ ] 图文教程链接（6个浏览器）
- [ ] 智能服务器预选（基于活跃度）
- [ ] Bot配置测试实时反馈
- [ ] 智能映射算法（相似度80%+）
- [ ] 用户手动测试通过（10人）

#### ✅ 一键安装包

- [ ] Windows exe生成（<200MB）
- [ ] macOS dmg生成（<200MB）
- [ ] Linux AppImage生成（<200MB）
- [ ] 内置Redis测试通过
- [ ] 内置Chromium测试通过
- [ ] 安装后首次启动成功率90%+
- [ ] 3个平台安装测试通过

#### ✅ Cookie导入

- [ ] 支持4种格式
- [ ] 格式自动识别准确率100%
- [ ] 实时验证功能
- [ ] Chrome扩展发布
- [ ] 视频教程录制（3个）
- [ ] 图文教程更新（2个）
- [ ] 用户测试成功率95%+

---

## 📞 联系开发团队

如需技术支持或讨论实施细节：
- GitHub Issues: https://github.com/gfchfjh/CSBJJWT/issues
- Email: dev@kookforwarder.com

---

**文档版本**: v1.0  
**更新日期**: 2025-10-25
