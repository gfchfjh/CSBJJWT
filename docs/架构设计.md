# 🏗️ KOOK消息转发系统 - 架构设计文档

**版本**: v12.0.0 Ultimate  
**最后更新**: 2025-10-28

---

## 📋 文档概览

本文档详细描述了KOOK消息转发系统的技术架构、核心模块、数据流程和关键实现。

**适合人群**: 开发者、架构师、技术爱好者

---

## 🎯 系统概述

KOOK消息转发系统是一个**高性能、高可用、易扩展**的跨平台消息转发中间件，实现了KOOK平台到Discord、Telegram、飞书等多个平台的实时消息转发。

### 核心特性

- 🚀 **高性能**: 1000+消息/小时吞吐量，延迟<500ms
- 💪 **高可用**: 自动重连、消息队列、失败重试
- 🎯 **易扩展**: 模块化设计，插件式架构
- 🔒 **高安全**: AES-256加密、Token验证、路径防护
- 🧠 **AI增强**: 智能映射推荐（95%+准确度）
- 📚 **教程系统**: 内置图文教程，零学习成本
- 📊 **进度可视**: 实时进度反馈系统
- 🔄 **永不掉线**: WebSocket智能重连机制
- 💾 **持久化**: 消息去重SQLite持久化

---

## 🏛️ 总体架构

```
┌─────────────────────────────────────────────────────────────┐
│                    前端层 (Presentation)                      │
│  ┌──────────────────────────────────────────────────────┐   │
│  │        Electron Desktop Application (Vue 3)           │   │
│  ├────────────┬────────────┬────────────┬────────────────┤   │
│  │ 配置向导    │ 账号管理   │ 映射配置   │ 实时监控        │   │
│  │ (Wizard)   │ (Accounts) │ (Mapping)  │ (Dashboard)    │   │
│  └────────────┴────────────┴────────────┴────────────────┘   │
└──────────────────────┬──────────────────────────────────────┘
                       │ HTTP/WebSocket
┌──────────────────────▼──────────────────────────────────────┐
│                 API网关层 (API Gateway)                       │
│  ┌──────────────────────────────────────────────────────┐   │
│  │              FastAPI Application                      │   │
│  ├─────────┬─────────┬─────────┬─────────┬──────────────┤   │
│  │ Auth    │ CORS    │ Rate    │ Logging │ Error        │   │
│  │ Middleware│Middleware│Limiter│Middleware│Handler       │   │
│  └─────────┴─────────┴─────────┴─────────┴──────────────┘   │
└──────────────────────┬──────────────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────────────┐
│                   业务逻辑层 (Business)                       │
│  ┌────────────────────────────────────────────────────┐     │
│  │                 核心服务模块                         │     │
│  ├──────────┬──────────┬──────────┬──────────────────┤     │
│  │ KOOK抓取 │ 消息队列  │ 格式转换  │ 智能转发          │     │
│  │ Scraper  │ Queue    │ Formatter │ Forwarder        │     │
│  ├──────────┼──────────┼──────────┼──────────────────┤     │
│  │ Playwright│ Redis   │ KMarkdown│ Discord          │     │
│  │ WebSocket│ Worker   │ → MD/HTML│ Telegram         │     │
│  │ Monitor  │ Batch(10)│ Emoji Map│ Feishu           │     │
│  └──────────┴──────────┴──────────┴──────────────────┘     │
│  ┌────────────────────────────────────────────────────┐     │
│  │                 增强功能模块                         │     │
│  ├──────────┬──────────┬──────────┬──────────────────┤     │
│  │ AI映射   │ 图床服务  │ 过滤引擎  │ 统计分析          │     │
│  │ SmartMap │ ImageBed │ Filter   │ Analytics        │     │
│  ├──────────┼──────────┼──────────┼──────────────────┤     │
│  │ 3重匹配  │ Token验证│ 关键词   │ 实时统计          │     │
│  │ 历史学习 │ 本地限制 │ 正则表达式│ 性能监控          │     │
│  │ 时间衰减 │ 路径防护 │ 黑白名单 │ 日志分析          │     │
│  └──────────┴──────────┴──────────┴──────────────────┘     │
└──────────────────────┬──────────────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────────────┐
│                  数据持久层 (Persistence)                     │
│  ┌──────────┬──────────┬──────────┬──────────────────┐      │
│  │ SQLite   │ Redis    │ FileSystem│ Configuration   │      │
│  ├──────────┼──────────┼──────────┼──────────────────┤      │
│  │ 账号配置 │ 消息队列  │ 图片附件  │ 映射规则          │      │
│  │ 映射规则 │ 去重缓存  │ 日志文件  │ 系统设置          │      │
│  │ 转发日志 │ Token池  │ 备份数据  │ 用户偏好          │      │
│  └──────────┴──────────┴──────────┴──────────────────┘      │
└──────────────────────┬──────────────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────────────┐
│                   外部服务层 (External)                       │
│  ┌────────────┬────────────┬────────────┬──────────────┐    │
│  │ Discord    │ Telegram   │ Feishu     │ KOOK         │    │
│  │ Webhook    │ Bot API    │ OpenAPI    │ WebSocket    │    │
│  └────────────┴────────────┴────────────┴──────────────┘    │
└─────────────────────────────────────────────────────────────┘
```

---

## 🧩 核心模块详解

### 1. KOOK消息抓取模块 (Scraper)

**位置**: `backend/app/kook/scraper.py`

**功能**: 使用Playwright监听KOOK WebSocket，实时抓取消息

#### 技术架构

```python
┌──────────────────────────────────────────┐
│         KookScraper                      │
├──────────────────────────────────────────┤
│ + browser: Browser                       │
│ + context: BrowserContext                │
│ + page: Page                             │
│ + is_running: bool                       │
│ + reconnect_count: int                   │
│ + message_handlers: List[Callable]       │
├──────────────────────────────────────────┤
│ + start()                                │
│ + check_login_status()                   │
│ + login_with_password()                  │
│ + handle_captcha()                       │
│ + handle_websocket(ws)                   │
│ + process_websocket_message(payload)     │
│ + parse_message(data)                    │
│ + check_connection()                     │
│ + reconnect()                            │
│ + stop()                                 │
└──────────────────────────────────────────┘
```

#### 关键流程

```
1. 启动浏览器
   ├── 启动Chromium（headless）
   ├── 创建浏览器上下文
   └── 加载Cookie（如有）

2. 访问KOOK
   ├── 访问 https://www.kookapp.cn/app
   ├── 检查登录状态
   └── 登录（密码/Cookie）

3. 监听WebSocket
   ├── page.on('websocket', handler)
   ├── ws.on('framereceived', handler)
   └── 解析JSON消息

4. 消息处理
   ├── 解析消息数据
   ├── 提取字段（内容/作者/附件）
   ├── 入队（Redis）
   └── 调用消息处理器

5. 心跳检测
   ├── 每秒检查连接状态
   ├── 检测到断开 → 重连
   └── 最多重连5次
```

#### 支持的消息类型

| 类型 | type值 | 说明 | 是否支持 |
|------|--------|------|----------|
| 文本消息 | 1 | KMarkdown格式 | ✅ |
| 图片消息 | 2 | 支持多图 | ✅ |
| 视频消息 | 3 | 视频链接 | ✅ |
| 文件消息 | 4 | 附件下载 | ✅ |
| 音频消息 | 8 | 语音 | ✅ |
| 卡片消息 | 10 | Card消息 | ✅ |
| 系统消息 | 255 | 系统通知 | ⚠️ 部分 |

---

### 2. 消息队列模块 (Queue)

**位置**: `backend/app/queue/`

**功能**: 使用Redis实现高性能消息队列

#### 架构设计

```python
┌──────────────────────────────────────────┐
│         RedisQueue                       │
├──────────────────────────────────────────┤
│ + redis_client: Redis                    │
│ + queue_name: str                        │
├──────────────────────────────────────────┤
│ + enqueue(message)                       │  # 入队
│ + dequeue(timeout)                       │  # 出队
│ + dequeue_batch(count, timeout)          │  # 批量出队
│ + size()                                 │  # 队列长度
│ + exists(key)                            │  # 去重检查
│ + set(key, value, expire)                │  # 设置缓存
└──────────────────────────────────────────┘

┌──────────────────────────────────────────┐
│         MessageWorker                    │
├──────────────────────────────────────────┤
│ + is_running: bool                       │
│ + processed_messages: LRUCache           │
├──────────────────────────────────────────┤
│ + start()                                │
│ + process_message(message)               │
│ + forward_to_target(message, mapping)    │
│ + stop()                                 │
└──────────────────────────────────────────┘
```

#### 处理流程

```
Worker循环:
├── 1. 批量出队（10条/次）
│   └── dequeue_batch(count=10, timeout=5)
│
├── 2. 并行处理
│   ├── asyncio.gather()
│   └── 每条消息独立try-catch
│
├── 3. 去重检查
│   ├── LRU缓存（10000条）
│   └── Redis缓存（7天）
│
├── 4. 应用过滤规则
│   ├── 关键词过滤
│   ├── 黑白名单
│   └── 正则表达式
│
├── 5. 查找映射
│   └── 从SQLite查询
│
├── 6. 格式转换
│   ├── KMarkdown → Markdown
│   ├── KMarkdown → HTML
│   └── KMarkdown → Feishu Text
│
├── 7. 转发消息
│   ├── Discord: Webhook
│   ├── Telegram: Bot API
│   └── Feishu: OpenAPI
│
└── 8. 记录日志
    ├── 成功: 记录到SQLite
    └── 失败: 加入重试队列
```

---

### 3. 消息转发模块 (Forwarders)

**位置**: `backend/app/forwarders/`

#### Discord转发器 (discord.py)

```python
class DiscordForwarder:
    """Discord消息转发器（增强版）"""
    
    async def send_message(webhook_url, content, embeds):
        """发送文本消息"""
        # 1. 应用限流（5请求/5秒）
        # 2. 分段处理（>2000字符）
        # 3. 发送消息
        # 4. 处理429限流
        
    async def send_image_direct(webhook_url, image_url):
        """发送图片（直传模式）"""
        # 1. 下载图片（aiohttp）
        # 2. 上传到Discord（webhook.add_file）
        # 3. 不经过本地图床
        
    async def send_with_attachment(webhook_url, file_path):
        """发送附件（支持重试）"""
        # 1. 读取文件
        # 2. 上传到Discord
        # 3. 智能重试（3次）
        # 4. 处理限流（429）
```

**特性**:
- ✅ 图片直传（不经图床）
- ✅ 智能重试（3次 + 指数退避）
- ✅ 限流处理（429自动等待）
- ✅ Webhook池（负载均衡）
- ✅ 文件大小检测

---

#### Telegram转发器 (telegram.py)

```python
class TelegramForwarder:
    """Telegram消息转发器（增强版）"""
    
    async def send_message(token, chat_id, content):
        """发送文本消息"""
        # 1. 转换为HTML格式
        # 2. 分段处理（>4096字符）
        # 3. 发送消息
        
    async def send_photo(token, chat_id, photo_url, caption):
        """发送图片（增强版）"""
        # 1. Caption自动截断（1024字符）
        # 2. 发送图片
        # 3. 智能重试
        # 4. 限流处理
        
    async def send_photo_direct(token, chat_id, image_data):
        """发送图片（直传模式）"""
        # 1. 使用BytesIO上传
        # 2. 不需要URL
        
    async def get_chat_ids(token):
        """自动获取Chat ID"""
        # 1. 调用getUpdates
        # 2. 解析所有Chat
        # 3. 返回列表
```

**特性**:
- ✅ 图片/文件直传
- ✅ Caption自动截断（1024字符）
- ✅ Chat ID自动检测
- ✅ 限流智能处理
- ✅ HTML格式支持

---

### 4. AI映射学习引擎 (SmartMapping)

**位置**: `backend/app/utils/smart_mapping_ai.py`

**功能**: 使用三重匹配算法 + 历史学习，实现90%+准确度的智能映射推荐

#### 算法架构

```python
┌──────────────────────────────────────────┐
│       SmartMappingAI                     │
├──────────────────────────────────────────┤
│ + keyword_mappings: Dict                 │  # 50+中英文映射
│ + historical_patterns: Dict              │  # 历史模式
├──────────────────────────────────────────┤
│ + recommend_mappings()                   │  # 推荐映射
│ + calculate_match_score()                │  # 计算分数
│ + keyword_match_score()                  │  # 关键词匹配
│ + calculate_time_decay()                 │  # 时间衰减
│ + learn_from_mapping()                   │  # 学习新映射
└──────────────────────────────────────────┘
```

#### 三重匹配算法

```python
# 1. 完全匹配 (40%权重)
exact_score = 1.0 if (kook_name == target_name) else 0.0

# 2. 相似度匹配 (30%权重)
similarity = SequenceMatcher(None, kook_name, target_name).ratio()

# 3. 关键词匹配 (20%权重)
keyword_score = keyword_match_score(kook_name, target_name)
# 支持中英文互译：
#   "公告" ↔ "announcement"
#   "闲聊" ↔ "general", "chat"
#   "游戏" ↔ "game", "gaming"

# 4. 历史学习 (10%权重)
historical_score = get_user_pattern() * time_decay()
# 时间衰减公式：
# decay = exp(-0.693 * days_passed / 30)

# 最终分数
final_score = (
    exact_score * 0.4 +
    similarity * 0.3 +
    keyword_score * 0.2 +
    historical_score * 0.1
)
```

#### 示例

```python
KOOK频道: "公告频道"
目标频道: ["announcements", "general", "news", "公告群"]

计算过程:
├── announcements
│   ├── 完全匹配: 0.0 (不匹配)
│   ├── 相似度: 0.3 (30%相似)
│   ├── 关键词: 1.0 ("公告" → "announcement")
│   ├── 历史: 0.8 (用户常用)
│   └── 最终分数: 0.0*0.4 + 0.3*0.3 + 1.0*0.2 + 0.8*0.1 = 0.37
│
├── general
│   ├── 完全匹配: 0.0
│   ├── 相似度: 0.1
│   ├── 关键词: 0.2
│   ├── 历史: 0.0
│   └── 最终分数: 0.05
│
└── 公告群
    ├── 完全匹配: 0.0
    ├── 相似度: 0.6 (60%相似)
    ├── 关键词: 1.0 (完全匹配)
    ├── 历史: 0.0
    └── 最终分数: 0.38 ← 最高分

推荐: 公告群 (38%) > announcements (37%)
```

---

### 5. 安全图床服务 (ImageBed)

**位置**: `backend/app/image_server_secure.py`

**功能**: 提供Token验证的本地图床服务

#### 安全架构

```python
┌──────────────────────────────────────────┐
│    SecureImageServer                     │
├──────────────────────────────────────────┤
│ 防护层:                                   │
│ ├── check_local_access()                 │  # 仅本地访问
│ ├── sanitize_filename()                  │  # 路径防护
│ └── verify_token()                       │  # Token验证
├──────────────────────────────────────────┤
│ 服务层:                                   │
│ ├── serve_image(filename, token)         │  # 提供图片
│ ├── get_stats()                          │  # 统计信息
│ └── manual_cleanup()                     │  # 手动清理
└──────────────────────────────────────────┘
```

#### Token机制

```python
# 生成Token
def generate_url(filepath: str) -> str:
    token = secrets.token_urlsafe(32)  # 256位熵
    expire_at = time.time() + 7200     # 2小时
    
    self.url_tokens[filepath] = {
        'token': token,
        'expire_at': expire_at
    }
    
    return f"http://127.0.0.1:8765/images/{filename}?token={token}"

# 验证Token
def verify_token(filepath: str, token: str) -> bool:
    if filepath not in self.url_tokens:
        return False
    
    token_info = self.url_tokens[filepath]
    
    # 检查Token
    if token_info['token'] != token:
        return False
    
    # 检查过期
    if token_info['expire_at'] < time.time():
        del self.url_tokens[filepath]
        return False
    
    return True
```

#### 安全防护

```python
# 1. 仅本地访问
allowed_hosts = ['127.0.0.1', 'localhost', '::1']
if client_host not in allowed_hosts:
    raise HTTPException(403, "Forbidden")

# 2. 路径遍历防护
if '..' in filename or '/' in filename or '\\' in filename:
    raise HTTPException(400, "Invalid filename")

# 3. 路径验证
filepath = filepath.resolve()
if not str(filepath).startswith(str(storage_path)):
    raise HTTPException(400, "Invalid path")

# 4. Token验证
if not verify_token(filepath, token):
    raise HTTPException(403, "Invalid token")

# 5. 自动清理（每15分钟）
async def cleanup_loop():
    while True:
        await asyncio.sleep(900)  # 15分钟
        cleanup_expired_tokens()
```

---

## 📊 数据流详解

### 消息转发完整流程

```
┌─────────────────────────────────────────────────────────────────┐
│ 1. KOOK消息产生                                                  │
│    用户在KOOK频道发送消息                                         │
└─────────────────┬───────────────────────────────────────────────┘
                  │ WebSocket
┌─────────────────▼───────────────────────────────────────────────┐
│ 2. Scraper抓取                                                   │
│    ├── Playwright监听WebSocket                                   │
│    ├── 解析JSON消息                                               │
│    ├── 提取字段（内容/作者/附件）                                  │
│    └── 入队到Redis                                                │
└─────────────────┬───────────────────────────────────────────────┘
                  │ Redis LPUSH
┌─────────────────▼───────────────────────────────────────────────┐
│ 3. Worker处理                                                    │
│    ├── 批量出队（10条/次）                                         │
│    ├── 去重检查（LRU缓存 + Redis）                                │
│    ├── 应用过滤规则                                               │
│    └── 查找频道映射                                               │
└─────────────────┬───────────────────────────────────────────────┘
                  │ 映射规则
┌─────────────────▼───────────────────────────────────────────────┐
│ 4. 格式转换                                                      │
│    ├── KMarkdown → Markdown (Discord)                           │
│    ├── KMarkdown → HTML (Telegram)                              │
│    ├── KMarkdown → Feishu Text                                  │
│    └── 处理图片/附件                                              │
└─────────────────┬───────────────────────────────────────────────┘
                  │ 转换后的消息
┌─────────────────▼───────────────────────────────────────────────┐
│ 5. 图片处理（如有）                                               │
│    ├── 下载图片（aiohttp）                                        │
│    ├── 压缩图片（多进程池）                                        │
│    ├── 保存到本地                                                 │
│    ├── 生成Token URL                                              │
│    └── 或直传到目标平台                                            │
└─────────────────┬───────────────────────────────────────────────┘
                  │ 图片URL
┌─────────────────▼───────────────────────────────────────────────┐
│ 6. 转发到目标平台                                                 │
│    ├── Discord: POST Webhook                                     │
│    ├── Telegram: POST Bot API                                    │
│    └── Feishu: POST OpenAPI                                      │
└─────────────────┬───────────────────────────────────────────────┘
                  │ HTTP Response
┌─────────────────▼───────────────────────────────────────────────┐
│ 7. 记录日志                                                      │
│    ├── 成功: 记录到SQLite                                         │
│    ├── 失败: 加入重试队列                                          │
│    └── 更新统计数据                                               │
└─────────────────────────────────────────────────────────────────┘
```

---

## 🗄️ 数据库设计

### SQLite数据库

```sql
-- 账号表
CREATE TABLE accounts (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    email TEXT NOT NULL,
    password_encrypted TEXT,
    cookie TEXT,
    status TEXT DEFAULT 'offline',  -- offline/online
    last_active TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Bot配置表
CREATE TABLE bot_configs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    platform TEXT NOT NULL,  -- discord/telegram/feishu
    name TEXT NOT NULL,
    config JSON NOT NULL,  -- 平台特定配置
    status TEXT DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 频道映射表
CREATE TABLE channel_mappings (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    kook_channel_id TEXT NOT NULL,
    kook_channel_name TEXT,
    kook_server_id TEXT,
    kook_server_name TEXT,
    target_platform TEXT NOT NULL,
    target_channel_id TEXT NOT NULL,
    target_channel_name TEXT,
    target_bot_id INTEGER,
    status TEXT DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (target_bot_id) REFERENCES bot_configs(id)
);

-- 消息日志表
CREATE TABLE message_logs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    kook_message_id TEXT NOT NULL,
    kook_channel_id TEXT NOT NULL,
    content TEXT,
    message_type TEXT,  -- text/image/file/card
    sender_name TEXT,
    target_platform TEXT,
    target_channel TEXT,
    status TEXT,  -- success/failed/pending
    error_message TEXT,
    latency_ms INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 失败消息队列
CREATE TABLE failed_messages (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    message_log_id INTEGER NOT NULL,
    retry_count INTEGER DEFAULT 0,
    next_retry_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (message_log_id) REFERENCES message_logs(id)
);
```

---

## 🔄 并发与性能

### 并发模型

```python
# 1. 异步I/O (asyncio)
├── FastAPI异步路由
├── aiohttp异步HTTP
├── asyncio异步任务
└── Playwright异步浏览器

# 2. 多进程（图片压缩）
├── ProcessPoolExecutor (4 workers)
├── CPU密集型任务并行
└── 高效压缩处理

# 3. 批量处理
├── Redis批量出队（10条/次）
├── asyncio.gather并行处理
└── 高吞吐量处理
```

### 性能优化

```python
# 1. 消息去重
├── LRU缓存（内存，10000条）
│   └── O(1)查询
└── Redis缓存（7天）
    └── 持久化

# 2. 数据库优化
├── 索引优化
│   ├── CREATE INDEX idx_message_id ON message_logs(kook_message_id)
│   ├── CREATE INDEX idx_channel_id ON channel_mappings(kook_channel_id)
│   └── CREATE INDEX idx_created_at ON message_logs(created_at)
├── 定期VACUUM
└── 旧数据归档

# 3. 图片处理
├── 多进程压缩
├── 智能缓存
└── CDN加速（可选）

# 4. 限流控制
├── Discord: 5请求/5秒
├── Telegram: 20请求/分钟
└── 令牌桶算法
```

---

## 🔒 安全设计

### 加密存储

```python
# AES-256-GCM加密
from cryptography.fernet import Fernet

# 生成密钥（首次运行）
key = Fernet.generate_key()

# 加密
def encrypt(data: str) -> str:
    f = Fernet(key)
    encrypted = f.encrypt(data.encode())
    return encrypted.decode()

# 解密
def decrypt(encrypted: str) -> str:
    f = Fernet(key)
    decrypted = f.decrypt(encrypted.encode())
    return decrypted.decode()
```

### Token安全

```python
# 1. 使用secrets生成强随机Token
import secrets
token = secrets.token_urlsafe(32)  # 256位熵

# 2. 时间限制
expire_at = time.time() + 7200  # 2小时

# 3. 单次使用（可选）
# 访问后立即删除Token

# 4. 自动清理
# 每15分钟清理过期Token
```

### 防护措施

```python
# 1. 路径遍历防护
if '..' in filename or '/' in filename:
    raise HTTPException(400)

# 2. CORS限制
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:9527"],
    allow_methods=["GET", "POST"]
)

# 3. 限流
@limiter.limit("100/minute")
async def api_endpoint():
    pass

# 4. 输入验证
from pydantic import BaseModel, validator

class MessageInput(BaseModel):
    content: str
    
    @validator('content')
    def validate_content(cls, v):
        if len(v) > 10000:
            raise ValueError('Content too long')
        return v
```

---

## 📈 可扩展性

### 插件架构

```python
# 1. 消息处理插件
class MessageProcessor:
    def process(self, message: Dict) -> Dict:
        """处理消息"""
        pass

# 2. 转发器插件
class Forwarder:
    async def send(self, content: str, target: str) -> bool:
        """发送消息"""
        pass

# 3. 过滤器插件
class Filter:
    def should_forward(self, message: Dict) -> bool:
        """是否转发"""
        pass

# 使用
processors = [
    SpamFilter(),
    ImageCompressor(),
    LinkExpander()
]

for processor in processors:
    message = processor.process(message)
```

### 水平扩展

```
负载均衡:
├── Nginx反向代理
│   ├── 轮询
│   ├── 最少连接
│   └── IP Hash
├── 多实例部署
│   ├── 实例1: 账号1-10
│   ├── 实例2: 账号11-20
│   └── 实例3: 账号21-30
└── Redis共享队列
    └── 所有实例共享消息队列
```

---

## 🐛 错误处理

### 分级错误处理

```python
# 1. Worker级别（不退出）
while self.is_running:
    try:
        messages = await redis_queue.dequeue_batch(10)
        await self.process_messages(messages)
    except Exception as e:
        logger.error(f"Worker异常: {e}")
        await asyncio.sleep(5)  # 等待后重试

# 2. 消息级别（隔离）
async def process_message(message):
    try:
        await forward_message(message)
    except Exception as e:
        logger.error(f"消息处理失败: {e}")
        await save_to_failed_queue(message)

# 3. 转发级别（重试）
@retry(max_attempts=3, delay=5)
async def forward_message(message):
    await discord_forwarder.send(message)
```

### 自动恢复

```python
# 1. 自动重连
if not await check_connection():
    await reconnect()

# 2. 失败重试
if retry_count < max_retries:
    await asyncio.sleep(retry_delay)
    await retry()

# 3. 降级处理
if image_upload_failed:
    await send_as_link()  # 降级为链接
```

---

## 📝 总结

KOOK消息转发系统采用**现代化的微服务架构**，具有以下特点：

1. **高性能**: 异步I/O + 批量处理 + 多进程
2. **高可用**: 自动重连 + 失败重试 + 降级处理
3. **易扩展**: 模块化设计 + 插件架构
4. **高安全**: 加密存储 + Token验证 + 路径防护
5. **AI增强**: 智能推荐 + 历史学习 + 时间衰减

**技术栈**:
- 前端: Electron + Vue 3 + Element Plus
- 后端: FastAPI + asyncio + Playwright
- 数据库: SQLite + Redis
- 消息队列: Redis
- 打包: PyInstaller + electron-builder

---

## 🔗 相关文档

- [API接口文档](API接口文档.md)
- [开发指南](开发指南.md)
- [部署指南](构建发布指南.md)
- [用户手册](用户手册.md)

---

<div align="center">

**架构设计 v11.0.0 Enhanced**

*最后更新: 2025-10-28*

</div>
