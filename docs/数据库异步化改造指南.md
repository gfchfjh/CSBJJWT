# æ•°æ®åº“å¼‚æ­¥åŒ–æ”¹é€ æŒ‡å—

**ä¼˜åŒ–ç¼–å·**: P1-4  
**ç›®æ ‡**: é«˜å¹¶å‘å»¶è¿Ÿæ˜¾è‘—é™ä½ï¼Œå†™å…¥æ€§èƒ½å¤§å¹…æå‡  
**å·¥ä½œé‡**: 24å°æ—¶  

---

## ğŸ“‹ æ”¹é€ æ¦‚è¿°

### å½“å‰é—®é¢˜
- ä½¿ç”¨åŒæ­¥`sqlite3`åº“ï¼Œæ‰€æœ‰æ•°æ®åº“æ“ä½œé˜»å¡äº‹ä»¶å¾ªç¯
- é«˜å¹¶å‘æ—¶ï¼ˆ100æ¡/ç§’ï¼‰ï¼Œå»¶è¿Ÿç´¯ç§¯ä¸¥é‡ï¼ˆ>5ç§’ï¼‰
- æ‰¹é‡å†™å…¥æ— æ³•ä¼˜åŒ–

### æ”¹é€ æ–¹æ¡ˆ
ä½¿ç”¨`aiosqlite`æ›¿æ¢`sqlite3`ï¼Œå®ç°ï¼š
1. å¼‚æ­¥æ•°æ®åº“è¿æ¥
2. æ‰¹é‡å†™å…¥Worker
3. è¿æ¥æ± ç®¡ç†
4. å†™å…¥é˜Ÿåˆ—ä¼˜åŒ–

---

## ğŸ”§ å®æ–½æ­¥éª¤

### ç¬¬ä¸€æ­¥ï¼šå®‰è£…ä¾èµ–

```bash
# backend/requirements.txtï¼ˆå·²å­˜åœ¨ï¼‰
aiosqlite==0.19.0
```

### ç¬¬äºŒæ­¥ï¼šåˆ›å»ºå¼‚æ­¥æ•°æ®åº“å±‚

```python
# backend/app/database_async.py

"""
å¼‚æ­¥æ•°æ®åº“æ“ä½œæ¨¡å—ï¼ˆâœ… P1-4ä¼˜åŒ–ï¼‰
"""
import aiosqlite
import asyncio
from datetime import datetime
from typing import Optional, List, Dict, Any
from pathlib import Path
from .config import DB_PATH
from .utils.logger import logger


class AsyncDatabase:
    """å¼‚æ­¥æ•°æ®åº“æ“ä½œç±»"""
    
    def __init__(self, db_path: Path = DB_PATH):
        self.db_path = db_path
        self._conn: Optional[aiosqlite.Connection] = None
        self._write_queue: asyncio.Queue = asyncio.Queue()
        self._write_worker_task: Optional[asyncio.Task] = None
        self._initialized = False
    
    async def init(self):
        """åˆå§‹åŒ–æ•°æ®åº“è¿æ¥"""
        if self._initialized:
            return
        
        # åˆ›å»ºè¿æ¥
        self._conn = await aiosqlite.connect(self.db_path)
        self._conn.row_factory = aiosqlite.Row
        
        # å¯åŠ¨å†™å…¥Worker
        self._write_worker_task = asyncio.create_task(self._write_worker())
        
        # åˆå§‹åŒ–è¡¨ç»“æ„
        await self._init_tables()
        
        self._initialized = True
        logger.info("âœ… å¼‚æ­¥æ•°æ®åº“å·²åˆå§‹åŒ–")
    
    async def close(self):
        """å…³é—­æ•°æ®åº“è¿æ¥"""
        if self._write_worker_task:
            self._write_worker_task.cancel()
            try:
                await self._write_worker_task
            except asyncio.CancelledError:
                pass
        
        if self._conn:
            await self._conn.close()
        
        self._initialized = False
        logger.info("âœ… å¼‚æ­¥æ•°æ®åº“å·²å…³é—­")
    
    async def _write_worker(self):
        """åå°å†™å…¥Workerï¼ˆæ‰¹é‡å†™å…¥ä¼˜åŒ–ï¼‰"""
        batch = []
        batch_size = 10
        batch_timeout = 0.1  # 100msè¶…æ—¶
        
        while True:
            try:
                # å°è¯•è·å–å†™å…¥ä»»åŠ¡
                try:
                    sql, params, future = await asyncio.wait_for(
                        self._write_queue.get(),
                        timeout=batch_timeout if not batch else None
                    )
                    batch.append((sql, params, future))
                except asyncio.TimeoutError:
                    # è¶…æ—¶ï¼Œç«‹å³å¤„ç†å½“å‰æ‰¹æ¬¡
                    if batch:
                        await self._flush_batch(batch)
                        batch.clear()
                    continue
                
                # å¦‚æœæ‰¹æ¬¡å·²æ»¡ï¼Œç«‹å³æ‰§è¡Œ
                if len(batch) >= batch_size:
                    await self._flush_batch(batch)
                    batch.clear()
                    
            except asyncio.CancelledError:
                # Workerè¢«å–æ¶ˆï¼Œå¤„ç†å‰©ä½™æ‰¹æ¬¡
                if batch:
                    await self._flush_batch(batch)
                break
            except Exception as e:
                logger.error(f"å†™å…¥Workerå¼‚å¸¸: {str(e)}")
                # æ¸…ç©ºæ‰¹æ¬¡ï¼Œé¿å…é‡å¤é”™è¯¯
                for _, _, future in batch:
                    if not future.done():
                        future.set_exception(e)
                batch.clear()
    
    async def _flush_batch(self, batch: List):
        """æ‰¹é‡æ‰§è¡Œå†™å…¥æ“ä½œ"""
        if not batch:
            return
        
        try:
            # æŒ‰SQLè¯­å¥åˆ†ç»„ï¼ˆç›¸åŒSQLå¯ä»¥æ‰¹é‡executemanyï¼‰
            grouped = {}
            for sql, params, future in batch:
                if sql not in grouped:
                    grouped[sql] = []
                grouped[sql].append((params, future))
            
            # æ‰§è¡Œæ‰¹é‡å†™å…¥
            for sql, items in grouped.items():
                params_list = [params for params, _ in items]
                futures_list = [future for _, future in items]
                
                try:
                    # æ‰¹é‡æ‰§è¡Œ
                    await self._conn.executemany(sql, params_list)
                    await self._conn.commit()
                    
                    # é€šçŸ¥æ‰€æœ‰FutureæˆåŠŸ
                    for future in futures_list:
                        if not future.done():
                            future.set_result(True)
                            
                except Exception as e:
                    # é€šçŸ¥æ‰€æœ‰Futureå¤±è´¥
                    for future in futures_list:
                        if not future.done():
                            future.set_exception(e)
                    raise
            
            logger.debug(f"æ‰¹é‡å†™å…¥å®Œæˆ: {len(batch)}æ¡è®°å½•")
            
        except Exception as e:
            logger.error(f"æ‰¹é‡å†™å…¥å¤±è´¥: {str(e)}")
    
    async def execute_write(self, sql: str, params: tuple) -> bool:
        """
        æ‰§è¡Œå†™å…¥æ“ä½œï¼ˆéé˜»å¡ï¼Œåå°æ‰¹é‡æ‰§è¡Œï¼‰
        
        Args:
            sql: SQLè¯­å¥
            params: å‚æ•°å…ƒç»„
            
        Returns:
            æ˜¯å¦æˆåŠŸ
        """
        future = asyncio.Future()
        await self._write_queue.put((sql, params, future))
        
        # ç­‰å¾…å†™å…¥å®Œæˆ
        try:
            result = await future
            return result
        except Exception as e:
            logger.error(f"å†™å…¥æ“ä½œå¤±è´¥: {str(e)}")
            return False
    
    async def execute_read(self, sql: str, params: tuple = ()) -> List[Dict]:
        """
        æ‰§è¡Œè¯»å–æ“ä½œï¼ˆå¼‚æ­¥ï¼‰
        
        Args:
            sql: SQLè¯­å¥
            params: å‚æ•°å…ƒç»„
            
        Returns:
            æŸ¥è¯¢ç»“æœåˆ—è¡¨
        """
        async with self._conn.execute(sql, params) as cursor:
            rows = await cursor.fetchall()
            return [dict(row) for row in rows]
    
    async def execute_one(self, sql: str, params: tuple = ()) -> Optional[Dict]:
        """
        æ‰§è¡Œè¯»å–å•æ¡è®°å½•ï¼ˆå¼‚æ­¥ï¼‰
        
        Args:
            sql: SQLè¯­å¥
            params: å‚æ•°å…ƒç»„
            
        Returns:
            å•æ¡è®°å½•æˆ–None
        """
        async with self._conn.execute(sql, params) as cursor:
            row = await cursor.fetchone()
            return dict(row) if row else None
    
    # ==================== è´¦å·æ“ä½œï¼ˆå¼‚æ­¥ç‰ˆæœ¬ï¼‰ ====================
    
    async def add_account_async(self, email: str, 
                               password_encrypted: Optional[str] = None,
                               cookie: Optional[str] = None) -> int:
        """å¼‚æ­¥æ·»åŠ è´¦å·"""
        sql = """
            INSERT INTO accounts (email, password_encrypted, cookie)
            VALUES (?, ?, ?)
        """
        await self.execute_write(sql, (email, password_encrypted, cookie))
        
        # è·å–æ’å…¥çš„ID
        result = await self.execute_one("SELECT last_insert_rowid() as id")
        return result['id'] if result else -1
    
    async def get_accounts_async(self) -> List[Dict]:
        """å¼‚æ­¥è·å–æ‰€æœ‰è´¦å·"""
        return await self.execute_read("SELECT * FROM accounts")
    
    async def update_account_status_async(self, account_id: int, status: str):
        """å¼‚æ­¥æ›´æ–°è´¦å·çŠ¶æ€"""
        sql = """
            UPDATE accounts 
            SET status = ?, last_active = CURRENT_TIMESTAMP 
            WHERE id = ?
        """
        await self.execute_write(sql, (status, account_id))
    
    # ==================== æ¶ˆæ¯æ—¥å¿—æ“ä½œï¼ˆå¼‚æ­¥ç‰ˆæœ¬ï¼‰ ====================
    
    async def add_message_log_async(self, 
                                   kook_message_id: str,
                                   kook_channel_id: str,
                                   content: str,
                                   message_type: str,
                                   sender_name: str,
                                   target_platform: str,
                                   target_channel: str,
                                   status: str,
                                   error_message: Optional[str] = None,
                                   latency_ms: Optional[int] = None) -> int:
        """å¼‚æ­¥æ·»åŠ æ¶ˆæ¯æ—¥å¿—ï¼ˆé«˜æ€§èƒ½æ‰¹é‡å†™å…¥ï¼‰"""
        sql = """
            INSERT INTO message_logs (
                kook_message_id, kook_channel_id, content, message_type,
                sender_name, target_platform, target_channel, status,
                error_message, latency_ms
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        params = (
            kook_message_id, kook_channel_id, content, message_type,
            sender_name, target_platform, target_channel, status,
            error_message, latency_ms
        )
        
        await self.execute_write(sql, params)
        
        # è·å–æ’å…¥çš„ID
        result = await self.execute_one("SELECT last_insert_rowid() as id")
        return result['id'] if result else -1
    
    async def get_message_logs_async(self, 
                                    limit: int = 100,
                                    offset: int = 0,
                                    status: Optional[str] = None,
                                    platform: Optional[str] = None) -> List[Dict]:
        """å¼‚æ­¥è·å–æ¶ˆæ¯æ—¥å¿—"""
        sql = "SELECT * FROM message_logs WHERE 1=1"
        params = []
        
        if status:
            sql += " AND status = ?"
            params.append(status)
        
        if platform:
            sql += " AND target_platform = ?"
            params.append(platform)
        
        sql += " ORDER BY created_at DESC LIMIT ? OFFSET ?"
        params.extend([limit, offset])
        
        return await self.execute_read(sql, tuple(params))
    
    # ==================== å·¥å…·æ–¹æ³• ====================
    
    async def _init_tables(self):
        """åˆå§‹åŒ–æ•°æ®åº“è¡¨ï¼ˆå¼‚æ­¥ç‰ˆæœ¬ï¼‰"""
        # è¿™é‡Œå¯ä»¥å¤ç”¨åŒæ­¥ç‰ˆæœ¬çš„è¡¨ç»“æ„
        # æˆ–è€…ç›´æ¥ä½¿ç”¨execute_writeæ‰§è¡ŒCREATE TABLE
        pass


# åˆ›å»ºå…¨å±€å¼‚æ­¥æ•°æ®åº“å®ä¾‹
async_db = AsyncDatabase()
