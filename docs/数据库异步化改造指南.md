# 数据库异步化改造指南

**优化编号**: P1-4  
**目标**: 高并发延迟显著降低，写入性能大幅提升  
**工作量**: 24小时  

---

## 📋 改造概述

### 当前问题
- 使用同步`sqlite3`库，所有数据库操作阻塞事件循环
- 高并发时（100条/秒），延迟累积严重（>5秒）
- 批量写入无法优化

### 改造方案
使用`aiosqlite`替换`sqlite3`，实现：
1. 异步数据库连接
2. 批量写入Worker
3. 连接池管理
4. 写入队列优化

---

## 🔧 实施步骤

### 第一步：安装依赖

```bash
# backend/requirements.txt（已存在）
aiosqlite==0.19.0
```

### 第二步：创建异步数据库层

```python
# backend/app/database_async.py

"""
异步数据库操作模块（✅ P1-4优化）
"""
import aiosqlite
import asyncio
from datetime import datetime
from typing import Optional, List, Dict, Any
from pathlib import Path
from .config import DB_PATH
from .utils.logger import logger


class AsyncDatabase:
    """异步数据库操作类"""
    
    def __init__(self, db_path: Path = DB_PATH):
        self.db_path = db_path
        self._conn: Optional[aiosqlite.Connection] = None
        self._write_queue: asyncio.Queue = asyncio.Queue()
        self._write_worker_task: Optional[asyncio.Task] = None
        self._initialized = False
    
    async def init(self):
        """初始化数据库连接"""
        if self._initialized:
            return
        
        # 创建连接
        self._conn = await aiosqlite.connect(self.db_path)
        self._conn.row_factory = aiosqlite.Row
        
        # 启动写入Worker
        self._write_worker_task = asyncio.create_task(self._write_worker())
        
        # 初始化表结构
        await self._init_tables()
        
        self._initialized = True
        logger.info("✅ 异步数据库已初始化")
    
    async def close(self):
        """关闭数据库连接"""
        if self._write_worker_task:
            self._write_worker_task.cancel()
            try:
                await self._write_worker_task
            except asyncio.CancelledError:
                pass
        
        if self._conn:
            await self._conn.close()
        
        self._initialized = False
        logger.info("✅ 异步数据库已关闭")
    
    async def _write_worker(self):
        """后台写入Worker（批量写入优化）"""
        batch = []
        batch_size = 10
        batch_timeout = 0.1  # 100ms超时
        
        while True:
            try:
                # 尝试获取写入任务
                try:
                    sql, params, future = await asyncio.wait_for(
                        self._write_queue.get(),
                        timeout=batch_timeout if not batch else None
                    )
                    batch.append((sql, params, future))
                except asyncio.TimeoutError:
                    # 超时，立即处理当前批次
                    if batch:
                        await self._flush_batch(batch)
                        batch.clear()
                    continue
                
                # 如果批次已满，立即执行
                if len(batch) >= batch_size:
                    await self._flush_batch(batch)
                    batch.clear()
                    
            except asyncio.CancelledError:
                # Worker被取消，处理剩余批次
                if batch:
                    await self._flush_batch(batch)
                break
            except Exception as e:
                logger.error(f"写入Worker异常: {str(e)}")
                # 清空批次，避免重复错误
                for _, _, future in batch:
                    if not future.done():
                        future.set_exception(e)
                batch.clear()
    
    async def _flush_batch(self, batch: List):
        """批量执行写入操作"""
        if not batch:
            return
        
        try:
            # 按SQL语句分组（相同SQL可以批量executemany）
            grouped = {}
            for sql, params, future in batch:
                if sql not in grouped:
                    grouped[sql] = []
                grouped[sql].append((params, future))
            
            # 执行批量写入
            for sql, items in grouped.items():
                params_list = [params for params, _ in items]
                futures_list = [future for _, future in items]
                
                try:
                    # 批量执行
                    await self._conn.executemany(sql, params_list)
                    await self._conn.commit()
                    
                    # 通知所有Future成功
                    for future in futures_list:
                        if not future.done():
                            future.set_result(True)
                            
                except Exception as e:
                    # 通知所有Future失败
                    for future in futures_list:
                        if not future.done():
                            future.set_exception(e)
                    raise
            
            logger.debug(f"批量写入完成: {len(batch)}条记录")
            
        except Exception as e:
            logger.error(f"批量写入失败: {str(e)}")
    
    async def execute_write(self, sql: str, params: tuple) -> bool:
        """
        执行写入操作（非阻塞，后台批量执行）
        
        Args:
            sql: SQL语句
            params: 参数元组
            
        Returns:
            是否成功
        """
        future = asyncio.Future()
        await self._write_queue.put((sql, params, future))
        
        # 等待写入完成
        try:
            result = await future
            return result
        except Exception as e:
            logger.error(f"写入操作失败: {str(e)}")
            return False
    
    async def execute_read(self, sql: str, params: tuple = ()) -> List[Dict]:
        """
        执行读取操作（异步）
        
        Args:
            sql: SQL语句
            params: 参数元组
            
        Returns:
            查询结果列表
        """
        async with self._conn.execute(sql, params) as cursor:
            rows = await cursor.fetchall()
            return [dict(row) for row in rows]
    
    async def execute_one(self, sql: str, params: tuple = ()) -> Optional[Dict]:
        """
        执行读取单条记录（异步）
        
        Args:
            sql: SQL语句
            params: 参数元组
            
        Returns:
            单条记录或None
        """
        async with self._conn.execute(sql, params) as cursor:
            row = await cursor.fetchone()
            return dict(row) if row else None
    
    # ==================== 账号操作（异步版本） ====================
    
    async def add_account_async(self, email: str, 
                               password_encrypted: Optional[str] = None,
                               cookie: Optional[str] = None) -> int:
        """异步添加账号"""
        sql = """
            INSERT INTO accounts (email, password_encrypted, cookie)
            VALUES (?, ?, ?)
        """
        await self.execute_write(sql, (email, password_encrypted, cookie))
        
        # 获取插入的ID
        result = await self.execute_one("SELECT last_insert_rowid() as id")
        return result['id'] if result else -1
    
    async def get_accounts_async(self) -> List[Dict]:
        """异步获取所有账号"""
        return await self.execute_read("SELECT * FROM accounts")
    
    async def update_account_status_async(self, account_id: int, status: str):
        """异步更新账号状态"""
        sql = """
            UPDATE accounts 
            SET status = ?, last_active = CURRENT_TIMESTAMP 
            WHERE id = ?
        """
        await self.execute_write(sql, (status, account_id))
    
    # ==================== 消息日志操作（异步版本） ====================
    
    async def add_message_log_async(self, 
                                   kook_message_id: str,
                                   kook_channel_id: str,
                                   content: str,
                                   message_type: str,
                                   sender_name: str,
                                   target_platform: str,
                                   target_channel: str,
                                   status: str,
                                   error_message: Optional[str] = None,
                                   latency_ms: Optional[int] = None) -> int:
        """异步添加消息日志（高性能批量写入）"""
        sql = """
            INSERT INTO message_logs (
                kook_message_id, kook_channel_id, content, message_type,
                sender_name, target_platform, target_channel, status,
                error_message, latency_ms
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        params = (
            kook_message_id, kook_channel_id, content, message_type,
            sender_name, target_platform, target_channel, status,
            error_message, latency_ms
        )
        
        await self.execute_write(sql, params)
        
        # 获取插入的ID
        result = await self.execute_one("SELECT last_insert_rowid() as id")
        return result['id'] if result else -1
    
    async def get_message_logs_async(self, 
                                    limit: int = 100,
                                    offset: int = 0,
                                    status: Optional[str] = None,
                                    platform: Optional[str] = None) -> List[Dict]:
        """异步获取消息日志"""
        sql = "SELECT * FROM message_logs WHERE 1=1"
        params = []
        
        if status:
            sql += " AND status = ?"
            params.append(status)
        
        if platform:
            sql += " AND target_platform = ?"
            params.append(platform)
        
        sql += " ORDER BY created_at DESC LIMIT ? OFFSET ?"
        params.extend([limit, offset])
        
        return await self.execute_read(sql, tuple(params))
    
    # ==================== 工具方法 ====================
    
    async def _init_tables(self):
        """初始化数据库表（异步版本）"""
        # 这里可以复用同步版本的表结构
        # 或者直接使用execute_write执行CREATE TABLE
        pass


# 创建全局异步数据库实例
async_db = AsyncDatabase()
