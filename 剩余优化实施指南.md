# 剩余优化任务实施指南

## P0-5: 图床管理界面完善

### 核心功能
1. **双视图模式切换** (网格视图 / 列表视图)
2. **Lightbox大图预览**
3. **搜索和排序功能**
4. **智能清理选项**

### 技术规范

#### 组件文件
- `frontend/src/views/ImageStorageUltra.vue`
  
#### 状态管理
```javascript
const viewMode = ref('grid') // 'grid' | 'list'
const images = ref([])
const searchQuery = ref('')
const sortBy = ref('time') // 'time' | 'size' | 'name'
const selectedImages = ref(new Set())
const lightboxVisible = ref(false)
const currentImage = ref(null)
```

#### API调用
```javascript
// 获取图片列表
GET /api/image-storage/list
Response: {
  images: [
    {id, filename, size, upload_time, last_access, url}
  ],
  stats: {total_images, total_size_mb, usage_percentage}
}

// 删除图片
DELETE /api/image-storage/delete
Body: {image_ids: [1, 2, 3]}

// 智能清理
POST /api/image-storage/cleanup
Body: {days: 7, max_size_gb: 10}
```

#### UI布局
```
┌─────────────────────────────────────┐
│ 🖼️ 图床管理                          │
├─────────────────────────────────────┤
│ 📊 统计卡片 (4个彩色卡片)             │
│ ├─ 总空间  ├─ 已用  ├─ 可用  ├─ 图片数│
│ └─ 动态进度条 (根据使用率变色)         │
├─────────────────────────────────────┤
│ 🔍 搜索框  📊 排序  🔄 视图切换       │
├─────────────────────────────────────┤
│ [网格视图]                           │
│ ┌───┐ ┌───┐ ┌───┐ ┌───┐            │
│ │🖼️ │ │🖼️ │ │🖼️ │ │🖼️ │            │
│ │100│ │200│ │150│ │300│ KB         │
│ └───┘ └───┘ └───┘ └───┘            │
│                                     │
│ [列表视图]                           │
│ ┌────────────────────────────────┐ │
│ │ 📄 image_123.jpg  │ 100KB │ ... │ │
│ │ 📄 image_456.jpg  │ 200KB │ ... │ │
│ └────────────────────────────────┘ │
├─────────────────────────────────────┤
│ 🗑️ 清理选项                          │
│ ○ 7天前  ○ 30天前  ○ 清空全部       │
└─────────────────────────────────────┘
```

---

## P0-6: 频道映射编辑器增强

### 核心功能
1. **SVG贝塞尔曲线连接**
2. **60+智能映射规则**
3. **置信度分级显示**
4. **一对多虚线显示**

### 技术规范

#### 智能映射规则扩展
```python
# backend/app/api/smart_mapping_enhanced.py (新增)

MAPPING_RULES = {
    # 中文直译
    "公告": ["announcements", "announcement", "news", "notice"],
    "活动": ["events", "event", "activity", "activities"],
    "更新": ["updates", "update", "changelog", "changes"],
    "讨论": ["discussion", "discuss", "chat", "talk"],
    "技术": ["tech", "technical", "technology", "dev"],
    "帮助": ["help", "support", "助手", "question"],
    "反馈": ["feedback", "建议", "suggestion"],
    "Bug": ["bugs", "issues", "问题"],
    "闲聊": ["chat", "off-topic", "random", "general"],
    "新手": ["newbie", "新人", "beginner"],
    
    # 英文翻译
    "general": ["综合", "通用", "一般", "常规"],
    "development": ["开发", "研发", "dev"],
    "community": ["社区", "交流", "community"],
    "showcase": ["展示", "作品", "分享"],
    "resources": ["资源", "素材", "下载"],
    
    # 游戏相关
    "游戏": ["game", "gaming", "play"],
    "公会": ["guild", "clan", "战队"],
    "招募": ["recruit", "招人", "组队"],
    "交易": ["trade", "市场", "trading"],
    
    # 更多规则...（共60+）
}

def calculate_confidence(source: str, target: str) -> float:
    """
    计算映射置信度
    
    算法:
    1. 完全匹配: 1.0
    2. 包含关系: 0.9
    3. Levenshtein距离: 0.5-0.8
    4. 规则匹配: 0.7
    5. 无匹配: 0.0
    """
    if source.lower() == target.lower():
        return 1.0
    
    if source in target or target in source:
        return 0.9
    
    # Levenshtein距离计算
    distance = levenshtein_distance(source, target)
    max_len = max(len(source), len(target))
    similarity = 1 - (distance / max_len)
    
    if similarity > 0.8:
        return 0.8
    elif similarity > 0.6:
        return 0.6
    
    # 规则匹配
    for cn, en_list in MAPPING_RULES.items():
        if source in cn or source in en_list:
            if target in cn or target in en_list:
                return 0.7
    
    return 0.0
```

#### SVG贝塞尔曲线
```javascript
// frontend/src/components/DraggableMappingUltimate.vue

// 计算贝塞尔曲线路径
function calculateBezierPath(x1, y1, x2, y2) {
  // 控制点：水平距离的1/3处
  const cx1 = x1 + (x2 - x1) / 3
  const cy1 = y1
  const cx2 = x2 - (x2 - x1) / 3
  const cy2 = y2
  
  return `M ${x1} ${y1} C ${cx1} ${cy1}, ${cx2} ${cy2}, ${x2} ${y2}`
}

// SVG渐变色定义
<defs>
  <linearGradient id="lineGradient" x1="0%" y1="0%" x2="100%" y2="0%">
    <stop offset="0%" style="stop-color:#409EFF;stop-opacity:1" />
    <stop offset="100%" style="stop-color:#67C23A;stop-opacity:1" />
  </linearGradient>
</defs>

// 绘制连线
<path
  :d="calculateBezierPath(source.x, source.y, target.x, target.y)"
  stroke="url(#lineGradient)"
  stroke-width="2"
  fill="none"
  :stroke-dasharray="isOneToMany ? '5,5' : 'none'"
  marker-end="url(#arrowhead)"
/>
```

---

## P0-7: 过滤规则界面优化

### 核心功能
1. **关键词Tag输入器**
2. **实时测试功能**
3. **用户选择器**
4. **规则预览**

### 技术规范

#### Tag输入组件
```vue
<template>
  <div class="keyword-tag-input">
    <el-tag
      v-for="tag in keywords"
      :key="tag"
      closable
      @close="removeTag(tag)"
      type="primary"
      size="large"
    >
      {{ tag }}
    </el-tag>
    
    <el-input
      v-model="newKeyword"
      placeholder="输入关键词后按回车"
      @keyup.enter="addTag"
      size="large"
      class="tag-input"
    />
  </div>
</template>

<script setup>
const keywords = ref(['广告', '代练', '外挂'])
const newKeyword = ref('')

const addTag = () => {
  if (newKeyword.value && !keywords.value.includes(newKeyword.value)) {
    keywords.value.push(newKeyword.value)
    newKeyword.value = ''
  }
}

const removeTag = (tag) => {
  const index = keywords.value.indexOf(tag)
  keywords.value.splice(index, 1)
}
</script>
```

#### 规则测试功能
```javascript
// 实时测试消息是否通过过滤
function testMessage() {
  const result = {
    passed: true,
    reason: '',
    rules_checked: []
  }
  
  // 测试黑名单关键词
  for (const keyword of blacklistKeywords.value) {
    if (testContent.value.includes(keyword)) {
      result.passed = false
      result.reason = `包含黑名单关键词: ${keyword}`
      result.rules_checked.push({
        type: 'keyword_blacklist',
        matched: keyword
      })
      return result
    }
  }
  
  // 测试白名单关键词
  if (whitelistKeywords.value.length > 0) {
    const hasWhitelisted = whitelistKeywords.value.some(
      kw => testContent.value.includes(kw)
    )
    if (!hasWhitelisted) {
      result.passed = false
      result.reason = '不包含白名单关键词'
      return result
    }
  }
  
  return result
}
```

---

## P0-8: 实时监控页增强

### 核心功能
1. **消息搜索**
2. **失败消息手动重试**
3. **日志导出（CSV/JSON）**
4. **增强统计图表**

### 技术规范

#### 搜索功能
```javascript
const searchQuery = ref('')
const searchFilters = ref({
  status: 'all', // 'all' | 'success' | 'failed' | 'pending'
  platform: 'all',
  dateRange: null
})

const filteredLogs = computed(() => {
  return logs.value.filter(log => {
    // 搜索内容匹配
    if (searchQuery.value && !log.content.includes(searchQuery.value)) {
      return false
    }
    
    // 状态过滤
    if (searchFilters.value.status !== 'all' && log.status !== searchFilters.value.status) {
      return false
    }
    
    // 平台过滤
    if (searchFilters.value.platform !== 'all' && log.platform !== searchFilters.value.platform) {
      return false
    }
    
    return true
  })
})
```

#### 日志导出
```javascript
async function exportLogs(format) {
  const data = filteredLogs.value
  
  if (format === 'csv') {
    const csv = [
      ['时间', '频道', '平台', '状态', '内容', '延迟'],
      ...data.map(log => [
        log.timestamp,
        log.channel,
        log.platform,
        log.status,
        log.content,
        log.latency_ms
      ])
    ].map(row => row.join(',')).join('\n')
    
    downloadFile(csv, 'logs.csv', 'text/csv')
  } else if (format === 'json') {
    const json = JSON.stringify(data, null, 2)
    downloadFile(json, 'logs.json', 'application/json')
  }
}

function downloadFile(content, filename, mimeType) {
  const blob = new Blob([content], { type: mimeType })
  const url = URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  a.download = filename
  a.click()
  URL.revokeObjectURL(url)
}
```

#### 手动重试
```javascript
async function retryFailedMessage(messageId) {
  try {
    await api.post(`/api/logs/retry/${messageId}`)
    ElMessage.success('重试请求已发送')
    // 刷新日志列表
    await loadLogs()
  } catch (error) {
    ElMessage.error('重试失败: ' + error.message)
  }
}

// 批量重试所有失败消息
async function retryAllFailed() {
  const failedMessages = logs.value.filter(log => log.status === 'failed')
  
  if (failedMessages.length === 0) {
    ElMessage.info('没有失败的消息')
    return
  }
  
  await ElMessageBox.confirm(
    `确定要重试 ${failedMessages.length} 条失败消息吗？`,
    '批量重试',
    { type: 'warning' }
  )
  
  for (const msg of failedMessages) {
    await retryFailedMessage(msg.id)
  }
}
```

---

## P1级和P2级任务规范

由于篇幅限制，P1和P2级任务的详细规范请参考：
- `docs/P1级优化实施指南.md`
- `docs/P2级优化实施指南.md`

---

## 实施建议

1. **按优先级实施**: P0 → P1 → P2
2. **增量交付**: 每完成一个功能点立即测试
3. **代码审查**: 确保代码质量和一致性
4. **文档同步更新**: 更新API文档和用户手册

---

**生成日期**: 2025-10-27  
**版本**: v1.0
