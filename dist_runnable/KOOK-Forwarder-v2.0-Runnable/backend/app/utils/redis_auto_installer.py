"""
‚úÖ P0-3Ê∑±Â∫¶‰ºòÂåñ: RedisËá™Âä®‰∏ãËΩΩÂÆâË£ÖÂô®
ÊîØÊåÅ‰ªéÂ§ö‰∏™ÈïúÂÉèÊ∫êËá™Âä®‰∏ãËΩΩÂπ∂ÂÆâË£ÖRedis
"""
import os
import sys
import platform
import asyncio
import aiohttp
import zipfile
import tarfile
import shutil
import subprocess
from pathlib import Path
from typing import Tuple, Optional, Callable, Dict, Any
from .logger import logger


class RedisAutoInstaller:
    """RedisËá™Âä®‰∏ãËΩΩÂÆâË£ÖÂô®"""
    
    # Redis‰∏ãËΩΩÊ∫êÔºàÂ§ö‰∏™ÈïúÂÉèÔºåÊåâ‰ºòÂÖàÁ∫ßÔºâ
    REDIS_DOWNLOAD_SOURCES = {
        "windows": [
            {
                "name": "GitHub tporadowski/redis",
                "version": "5.0.14.1",
                "url": "https://github.com/tporadowski/redis/releases/download/v5.0.14.1/Redis-x64-5.0.14.1.zip",
                "size_mb": 5.2,
                "type": "zip"
            },
            {
                "name": "GitHub microsoftarchive/redis",
                "version": "3.2.100",
                "url": "https://github.com/microsoftarchive/redis/releases/download/win-3.2.100/Redis-x64-3.2.100.zip",
                "size_mb": 3.8,
                "type": "zip"
            }
        ],
        "linux": [
            {
                "name": "Redis.io Official",
                "version": "stable",
                "url": "https://download.redis.io/redis-stable.tar.gz",
                "size_mb": 2.5,
                "type": "tar.gz",
                "compile": True  # ÈúÄË¶ÅÁºñËØë
            },
            {
                "name": "GitHub redis/redis",
                "version": "7.2.0",
                "url": "https://github.com/redis/redis/archive/refs/tags/7.2.0.tar.gz",
                "size_mb": 3.1,
                "type": "tar.gz",
                "compile": True
            }
        ],
        "darwin": [  # macOS
            {
                "name": "Redis.io Official",
                "version": "stable",
                "url": "https://download.redis.io/redis-stable.tar.gz",
                "size_mb": 2.5,
                "type": "tar.gz",
                "compile": True
            }
        ]
    }
    
    def __init__(self, install_dir: Path):
        """
        ÂàùÂßãÂåñÂÆâË£ÖÂô®
        
        Args:
            install_dir: RedisÂÆâË£ÖÁõÆÂΩï
        """
        self.install_dir = Path(install_dir)
        self.install_dir.mkdir(parents=True, exist_ok=True)
        
        self.system = platform.system().lower()
        self.download_progress_callback: Optional[Callable] = None
        
        # ‰∏¥Êó∂‰∏ãËΩΩÁõÆÂΩï
        self.download_dir = self.install_dir / "download"
        self.download_dir.mkdir(exist_ok=True)
        
    def set_progress_callback(self, callback: Callable[[Dict[str, Any]], None]):
        """
        ËÆæÁΩÆ‰∏ãËΩΩËøõÂ∫¶ÂõûË∞ÉÂáΩÊï∞
        
        Args:
            callback: ÂõûË∞ÉÂáΩÊï∞ÔºåÊé•Êî∂ËøõÂ∫¶‰ø°ÊÅØÂ≠óÂÖ∏
                     {
                         "status": "downloading" | "extracting" | "compiling" | "complete",
                         "progress": 0-100,
                         "message": "Áä∂ÊÄÅÊ∂àÊÅØ",
                         "current_mb": ÂΩìÂâç‰∏ãËΩΩMB,
                         "total_mb": ÊÄªÂ§ßÂ∞èMB
                     }
        """
        self.download_progress_callback = callback
        
    def _emit_progress(self, status: str, progress: int, message: str, **kwargs):
        """Ëß¶ÂèëËøõÂ∫¶ÂõûË∞É"""
        if self.download_progress_callback:
            try:
                self.download_progress_callback({
                    "status": status,
                    "progress": progress,
                    "message": message,
                    **kwargs
                })
            except Exception as e:
                logger.error(f"ËøõÂ∫¶ÂõûË∞ÉÂ§±Ë¥•: {e}")
    
    async def download_and_install(self) -> Tuple[bool, str]:
        """
        ‰∏ãËΩΩÂπ∂ÂÆâË£ÖRedis
        
        Returns:
            (success, message)
        """
        try:
            # Ëé∑ÂèñÂΩìÂâçÁ≥ªÁªüÁöÑ‰∏ãËΩΩÊ∫ê
            sources = self.REDIS_DOWNLOAD_SOURCES.get(self.system)
            
            if not sources:
                return False, f"‰∏çÊîØÊåÅÁöÑÊìç‰ΩúÁ≥ªÁªü: {self.system}"
            
            logger.info(f"üåê Á≥ªÁªü: {self.system}ÔºåÂÖ±Êúâ {len(sources)} ‰∏™‰∏ãËΩΩÊ∫ê")
            
            # Â∞ùËØïÊØè‰∏™‰∏ãËΩΩÊ∫ê
            for idx, source in enumerate(sources, 1):
                logger.info(f"üì• Â∞ùËØï‰∏ãËΩΩÊ∫ê {idx}/{len(sources)}: {source['name']}")
                self._emit_progress("downloading", 0, f"ËøûÊé• {source['name']}...")
                
                try:
                    # ‰∏ãËΩΩRedis
                    download_file = await self._download_from_source(source)
                    
                    if not download_file:
                        logger.warning(f"‰ªé {source['name']} ‰∏ãËΩΩÂ§±Ë¥•")
                        continue
                    
                    logger.info(f"‚úÖ ‰∏ãËΩΩÂÆåÊàê: {download_file}")
                    
                    # Ëß£Âéã
                    self._emit_progress("extracting", 80, "Ê≠£Âú®Ëß£ÂéãÊñá‰ª∂...")
                    extract_success = await self._extract_file(download_file, source)
                    
                    if not extract_success:
                        logger.warning(f"Ëß£ÂéãÂ§±Ë¥•: {download_file}")
                        continue
                    
                    logger.info("‚úÖ Ëß£ÂéãÂÆåÊàê")
                    
                    # Â¶ÇÊûúÈúÄË¶ÅÁºñËØëÔºàLinux/macOSÔºâ
                    if source.get("compile", False):
                        self._emit_progress("compiling", 85, "Ê≠£Âú®ÁºñËØëRedis...")
                        compile_success = await self._compile_redis()
                        
                        if not compile_success:
                            logger.warning("ÁºñËØëÂ§±Ë¥•")
                            continue
                        
                        logger.info("‚úÖ ÁºñËØëÂÆåÊàê")
                    
                    # Ê∏ÖÁêÜ‰∏¥Êó∂Êñá‰ª∂
                    self._cleanup_temp_files(download_file)
                    
                    # È™åËØÅÂÆâË£Ö
                    if self._verify_installation():
                        self._emit_progress("complete", 100, "RedisÂÆâË£ÖÊàêÂäü")
                        return True, f"RedisÂ∑≤‰ªé {source['name']} ÂÆâË£ÖÊàêÂäü"
                    else:
                        logger.warning("ÂÆâË£ÖÈ™åËØÅÂ§±Ë¥•")
                        continue
                    
                except Exception as e:
                    logger.error(f"‰ªé {source['name']} ÂÆâË£ÖÂ§±Ë¥•: {str(e)}")
                    import traceback
                    logger.error(traceback.format_exc())
                    continue
            
            # ÊâÄÊúâÊ∫êÈÉΩÂ§±Ë¥•
            return False, "ÊâÄÊúâ‰∏ãËΩΩÊ∫êÂùáÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÁΩëÁªúËøûÊé•ÊàñÊâãÂä®ÂÆâË£ÖRedis"
            
        except Exception as e:
            logger.error(f"RedisÂÆâË£ÖÂºÇÂ∏∏: {str(e)}")
            return False, f"ÂÆâË£ÖÂºÇÂ∏∏: {str(e)}"
    
    async def _download_from_source(self, source: Dict[str, Any]) -> Optional[Path]:
        """
        ‰ªéÊåáÂÆöÊ∫ê‰∏ãËΩΩÊñá‰ª∂
        
        Args:
            source: ‰∏ãËΩΩÊ∫ê‰ø°ÊÅØ
            
        Returns:
            ‰∏ãËΩΩÁöÑÊñá‰ª∂Ë∑ØÂæÑÔºåÂ§±Ë¥•ËøîÂõûNone
        """
        try:
            url = source["url"]
            filename = Path(url).name
            download_path = self.download_dir / filename
            
            # Â¶ÇÊûúÂ∑≤Áªè‰∏ãËΩΩËøáÔºåÂÖàÂà†Èô§
            if download_path.exists():
                download_path.unlink()
            
            logger.info(f"üì• ‰∏ãËΩΩ: {url}")
            logger.info(f"üíæ ‰øùÂ≠òÂà∞: {download_path}")
            
            # ‰∏ãËΩΩÊñá‰ª∂
            timeout = aiohttp.ClientTimeout(total=300, connect=30)  # 5ÂàÜÈíüË∂ÖÊó∂
            
            async with aiohttp.ClientSession(timeout=timeout) as session:
                async with session.get(url) as response:
                    if response.status != 200:
                        logger.error(f"‰∏ãËΩΩÂ§±Ë¥•: HTTP {response.status}")
                        return None
                    
                    # Ëé∑ÂèñÊñá‰ª∂Â§ßÂ∞è
                    total_size = int(response.headers.get('content-length', 0))
                    total_mb = total_size / (1024 * 1024) if total_size else source.get("size_mb", 0)
                    
                    logger.info(f"üì¶ Êñá‰ª∂Â§ßÂ∞è: {total_mb:.2f} MB")
                    
                    # ‰∏ãËΩΩÂπ∂ÊòæÁ§∫ËøõÂ∫¶
                    downloaded = 0
                    chunk_size = 8192
                    
                    with open(download_path, 'wb') as f:
                        async for chunk in response.content.iter_chunked(chunk_size):
                            f.write(chunk)
                            downloaded += len(chunk)
                            
                            # Êõ¥Êñ∞ËøõÂ∫¶
                            if total_size > 0:
                                progress = int((downloaded / total_size) * 70)  # ‰∏ãËΩΩÂç†70%ËøõÂ∫¶
                                current_mb = downloaded / (1024 * 1024)
                                
                                self._emit_progress(
                                    "downloading",
                                    progress,
                                    f"‰∏ãËΩΩ‰∏≠: {current_mb:.1f}/{total_mb:.1f} MB",
                                    current_mb=current_mb,
                                    total_mb=total_mb
                                )
                    
                    logger.info(f"‚úÖ ‰∏ãËΩΩÂÆåÊàê: {download_path}")
                    return download_path
                    
        except asyncio.TimeoutError:
            logger.error("‰∏ãËΩΩË∂ÖÊó∂")
            return None
        except Exception as e:
            logger.error(f"‰∏ãËΩΩÂºÇÂ∏∏: {str(e)}")
            return None
    
    async def _extract_file(self, file_path: Path, source: Dict[str, Any]) -> bool:
        """
        Ëß£Âéã‰∏ãËΩΩÁöÑÊñá‰ª∂
        
        Args:
            file_path: ‰∏ãËΩΩÁöÑÊñá‰ª∂Ë∑ØÂæÑ
            source: ‰∏ãËΩΩÊ∫ê‰ø°ÊÅØ
            
        Returns:
            ÊòØÂê¶ÊàêÂäü
        """
        try:
            file_type = source.get("type", "")
            
            logger.info(f"üì¶ ÂºÄÂßãËß£Âéã: {file_path} (Á±ªÂûã: {file_type})")
            
            if file_type == "zip":
                # Ëß£ÂéãZIP
                with zipfile.ZipFile(file_path, 'r') as zip_ref:
                    # Ëé∑ÂèñÂéãÁº©ÂåÖÂÜÖÁöÑÊñá‰ª∂ÂàóË°®
                    members = zip_ref.namelist()
                    
                    # Â¶ÇÊûúÊúâÈ°∂Â±ÇÁõÆÂΩïÔºåÊèêÂèñÂà∞install_dir
                    # Âê¶ÂàôÁõ¥Êé•ÊèêÂèñ
                    has_top_dir = len(set(m.split('/')[0] for m in members if '/' in m)) == 1
                    
                    if has_top_dir:
                        # Ëß£ÂéãÂà∞‰∏¥Êó∂ÁõÆÂΩïÔºåÁÑ∂ÂêéÁßªÂä®Êñá‰ª∂
                        temp_extract = self.download_dir / "temp_extract"
                        temp_extract.mkdir(exist_ok=True)
                        
                        zip_ref.extractall(temp_extract)
                        
                        # ÊâæÂà∞È°∂Â±ÇÁõÆÂΩï
                        top_dir = next(temp_extract.iterdir())
                        
                        # ÁßªÂä®Êñá‰ª∂Âà∞install_dir
                        for item in top_dir.iterdir():
                            dest = self.install_dir / item.name
                            if dest.exists():
                                if dest.is_dir():
                                    shutil.rmtree(dest)
                                else:
                                    dest.unlink()
                            shutil.move(str(item), str(dest))
                        
                        # Ê∏ÖÁêÜ‰∏¥Êó∂ÁõÆÂΩï
                        shutil.rmtree(temp_extract)
                    else:
                        # Áõ¥Êé•Ëß£ÂéãÂà∞install_dir
                        zip_ref.extractall(self.install_dir)
                    
                    logger.info(f"‚úÖ ZIPËß£ÂéãÊàêÂäüÔºåÂÖ± {len(members)} ‰∏™Êñá‰ª∂")
                    
            elif file_type == "tar.gz":
                # Ëß£Âéãtar.gz
                with tarfile.open(file_path, 'r:gz') as tar_ref:
                    members = tar_ref.getmembers()
                    
                    # Ëß£ÂéãÂà∞‰∏¥Êó∂ÁõÆÂΩï
                    temp_extract = self.download_dir / "temp_extract"
                    temp_extract.mkdir(exist_ok=True)
                    
                    tar_ref.extractall(temp_extract)
                    
                    # ÊâæÂà∞È°∂Â±ÇÁõÆÂΩïÔºàÈÄöÂ∏∏ÊòØredis-x.x.xÔºâ
                    top_dirs = [d for d in temp_extract.iterdir() if d.is_dir()]
                    
                    if top_dirs:
                        source_dir = top_dirs[0]
                        
                        # ÁßªÂä®srcÁõÆÂΩïÂà∞install_dir
                        src_dir = source_dir / "src"
                        if src_dir.exists():
                            # Â§çÂà∂srcÂÜÖÂÆπÂà∞install_dir
                            for item in source_dir.iterdir():
                                dest = self.install_dir / item.name
                                if dest.exists():
                                    if dest.is_dir():
                                        shutil.rmtree(dest)
                                    else:
                                        dest.unlink()
                                
                                if item.is_dir():
                                    shutil.copytree(item, dest)
                                else:
                                    shutil.copy2(item, dest)
                        
                        # Ê∏ÖÁêÜ‰∏¥Êó∂ÁõÆÂΩï
                        shutil.rmtree(temp_extract)
                        
                        logger.info(f"‚úÖ TAR.GZËß£ÂéãÊàêÂäüÔºåÂÖ± {len(members)} ‰∏™Êñá‰ª∂")
                    else:
                        logger.error("Êú™ÊâæÂà∞È°∂Â±ÇÁõÆÂΩï")
                        return False
            else:
                logger.error(f"‰∏çÊîØÊåÅÁöÑÊñá‰ª∂Á±ªÂûã: {file_type}")
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"Ëß£ÂéãÂ§±Ë¥•: {str(e)}")
            import traceback
            logger.error(traceback.format_exc())
            return False
    
    async def _compile_redis(self) -> bool:
        """
        ÁºñËØëRedisÔºàLinux/macOSÔºâ
        
        Returns:
            ÊòØÂê¶ÊàêÂäü
        """
        try:
            # Ê£ÄÊü•ÊòØÂê¶ÊúâMakefile
            makefile = self.install_dir / "Makefile"
            if not makefile.exists():
                logger.warning("Êú™ÊâæÂà∞MakefileÔºåË∑≥ËøáÁºñËØë")
                return True
            
            logger.info("üî® ÂºÄÂßãÁºñËØëRedis...")
            
            # ÊâßË°åmake
            process = await asyncio.create_subprocess_exec(
                'make',
                cwd=str(self.install_dir),
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=180)
            
            if process.returncode == 0:
                logger.info("‚úÖ RedisÁºñËØëÊàêÂäü")
                
                # Â§çÂà∂ÁºñËØëÂ•ΩÁöÑÂèØÊâßË°åÊñá‰ª∂Âà∞Ê†πÁõÆÂΩï
                src_dir = self.install_dir / "src"
                if src_dir.exists():
                    for binary in ["redis-server", "redis-cli"]:
                        src_file = src_dir / binary
                        if src_file.exists():
                            dest_file = self.install_dir / binary
                            shutil.copy2(src_file, dest_file)
                            os.chmod(dest_file, 0o755)
                            logger.info(f"‚úÖ Â§çÂà∂: {binary}")
                
                return True
            else:
                error_msg = stderr.decode('utf-8', errors='ignore')
                logger.error(f"ÁºñËØëÂ§±Ë¥•: {error_msg}")
                return False
                
        except asyncio.TimeoutError:
            logger.error("ÁºñËØëË∂ÖÊó∂Ôºà3ÂàÜÈíüÔºâ")
            return False
        except Exception as e:
            logger.error(f"ÁºñËØëÂºÇÂ∏∏: {str(e)}")
            return False
    
    def _verify_installation(self) -> bool:
        """
        È™åËØÅRedisÂÆâË£Ö
        
        Returns:
            ÊòØÂê¶ÊàêÂäüÂÆâË£Ö
        """
        try:
            # Ê£ÄÊü•redis-serverÊòØÂê¶Â≠òÂú®
            if self.system == "windows":
                redis_server = self.install_dir / "redis-server.exe"
            else:
                redis_server = self.install_dir / "redis-server"
            
            if not redis_server.exists():
                logger.error(f"Êú™ÊâæÂà∞redis-server: {redis_server}")
                return False
            
            # Ê£ÄÊü•ÊòØÂê¶ÂèØÊâßË°å
            if not os.access(redis_server, os.X_OK):
                logger.warning(f"redis-server‰∏çÂèØÊâßË°åÔºåÂ∞ùËØïÊ∑ªÂä†ÊâßË°åÊùÉÈôê")
                try:
                    os.chmod(redis_server, 0o755)
                except Exception as e:
                    logger.error(f"Ê∑ªÂä†ÊâßË°åÊùÉÈôêÂ§±Ë¥•: {e}")
                    return False
            
            logger.info(f"‚úÖ RedisÈ™åËØÅÊàêÂäü: {redis_server}")
            return True
            
        except Exception as e:
            logger.error(f"È™åËØÅÂÆâË£ÖÂ§±Ë¥•: {str(e)}")
            return False
    
    def _cleanup_temp_files(self, download_file: Path):
        """Ê∏ÖÁêÜ‰∏¥Êó∂Êñá‰ª∂"""
        try:
            if download_file.exists():
                download_file.unlink()
                logger.info(f"üóëÔ∏è Ê∏ÖÁêÜ‰∏¥Êó∂Êñá‰ª∂: {download_file}")
        except Exception as e:
            logger.warning(f"Ê∏ÖÁêÜ‰∏¥Êó∂Êñá‰ª∂Â§±Ë¥•: {e}")
    
    async def check_and_install_if_needed(self) -> Tuple[bool, str]:
        """
        Ê£ÄÊü•RedisÊòØÂê¶Â∑≤ÂÆâË£ÖÔºåÂ¶ÇÊú™ÂÆâË£ÖÂàôËá™Âä®‰∏ãËΩΩ
        
        Returns:
            (success, message)
        """
        # Ê£ÄÊü•ÊòØÂê¶Â∑≤ÂÆâË£Ö
        if self._verify_installation():
            return True, "RedisÂ∑≤ÂÆâË£Ö"
        
        # Ëá™Âä®‰∏ãËΩΩÂÆâË£Ö
        logger.info("RedisÊú™ÂÆâË£ÖÔºåÂºÄÂßãËá™Âä®‰∏ãËΩΩ...")
        return await self.download_and_install()


# ‰æøÊç∑ÂáΩÊï∞
async def ensure_redis_installed(install_dir: Path, progress_callback: Optional[Callable] = None) -> Tuple[bool, str]:
    """
    Á°Æ‰øùRedisÂ∑≤ÂÆâË£Ö
    
    Args:
        install_dir: ÂÆâË£ÖÁõÆÂΩï
        progress_callback: ËøõÂ∫¶ÂõûË∞ÉÂáΩÊï∞
        
    Returns:
        (success, message)
    """
    installer = RedisAutoInstaller(install_dir)
    
    if progress_callback:
        installer.set_progress_callback(progress_callback)
    
    return await installer.check_and_install_if_needed()
