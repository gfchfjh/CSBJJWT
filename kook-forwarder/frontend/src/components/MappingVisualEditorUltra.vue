<template>
  <div class="mapping-visual-editor-ultra">
    <!-- Â∑•ÂÖ∑Ê†è -->
    <div class="editor-toolbar">
      <el-button type="primary" @click="smartMapping">
        <el-icon><MagicStick /></el-icon>
        Êô∫ËÉΩÊò†Â∞Ñ
      </el-button>
      <el-button @click="clearAllMappings">
        <el-icon><Delete /></el-icon>
        Ê∏ÖÁ©∫Êò†Â∞Ñ
      </el-button>
      <el-button @click="saveMappings" :loading="saving">
        <el-icon><Check /></el-icon>
        ‰øùÂ≠òÊò†Â∞Ñ
      </el-button>
      <el-divider direction="vertical" />
      <el-switch
        v-model="showConnections"
        active-text="ÊòæÁ§∫ËøûÊé•Á∫ø"
        inactive-text="ÈöêËóèËøûÊé•Á∫ø"
      />
    </div>

    <!-- ‰∏ªÁºñËæëÂå∫Âüü -->
    <div class="editor-main" ref="editorContainer">
      <!-- Â∑¶‰æßÔºöKOOKÈ¢ëÈÅìÂàóË°® -->
      <div class="channel-panel left-panel">
        <div class="panel-header">
          <h3>üì¢ KOOKÈ¢ëÈÅìÔºàÊ∫êÔºâ</h3>
          <el-input
            v-model="leftSearch"
            placeholder="ÊêúÁ¥¢È¢ëÈÅì..."
            clearable
            size="small"
            style="width: 200px"
          >
            <template #prefix>
              <el-icon><Search /></el-icon>
            </template>
          </el-input>
        </div>

        <div class="panel-content" ref="leftPanel">
          <div
            v-for="server in filteredKookServers"
            :key="server.id"
            class="server-group"
          >
            <div class="server-header">
              <el-icon><FolderOpened /></el-icon>
              <span>{{ server.name }}</span>
              <el-tag size="small">{{ server.channels?.length || 0 }}‰∏™È¢ëÈÅì</el-tag>
            </div>

            <div class="channel-list">
              <div
                v-for="channel in server.channels"
                :key="channel.id"
                :ref="`kook-${channel.id}`"
                class="channel-item kook-channel"
                :class="{ 'is-mapped': isMapped(channel.id) }"
                :data-channel-id="channel.id"
                :draggable="true"
                @dragstart="handleDragStart($event, channel, 'kook')"
                @dragend="handleDragEnd"
              >
                <el-icon v-if="channel.type === 'voice'"><Headset /></el-icon>
                <el-icon v-else><ChatDotRound /></el-icon>
                <span>{{ channel.name }}</span>
                <el-tag
                  v-if="getMappingCount(channel.id) > 0"
                  size="small"
                  type="success"
                >
                  {{ getMappingCount(channel.id) }}‰∏™Êò†Â∞Ñ
                </el-tag>
              </div>
            </div>
          </div>

          <el-empty
            v-if="filteredKookServers.length === 0"
            description="ÊöÇÊó†È¢ëÈÅì"
            :image-size="80"
          />
        </div>
      </div>

      <!-- SVGËøûÊé•Á∫øÁîªÂ∏É -->
      <svg
        v-if="showConnections"
        class="connections-canvas"
        :style="{ width: canvasWidth + 'px', height: canvasHeight + 'px' }"
      >
        <defs>
          <!-- ÂÆö‰πâÊ∏êÂèòËâ≤ -->
          <linearGradient id="lineGradient" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" style="stop-color:#409EFF;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#67C23A;stop-opacity:1" />
          </linearGradient>
          <!-- ÁÆ≠Â§¥Ê†áËÆ∞ -->
          <marker
            id="arrowhead"
            markerWidth="10"
            markerHeight="10"
            refX="9"
            refY="3"
            orient="auto"
          >
            <polygon points="0 0, 10 3, 0 6" fill="#67C23A" />
          </marker>
        </defs>

        <!-- ÁªòÂà∂Ë¥ùÂ°ûÂ∞îÊõ≤Á∫øËøûÊé•Á∫ø -->
        <path
          v-for="(connection, index) in connections"
          :key="`connection-${index}`"
          :d="connection.path"
          stroke="url(#lineGradient)"
          stroke-width="3"
          fill="none"
          marker-end="url(#arrowhead)"
          class="connection-line"
          @click="removeConnection(connection)"
        />

        <!-- ‰∏¥Êó∂ÊãñÊãΩËøûÊé•Á∫ø -->
        <path
          v-if="tempConnection"
          :d="tempConnection"
          stroke="#409EFF"
          stroke-width="3"
          stroke-dasharray="5,5"
          fill="none"
          class="temp-connection-line"
        />
      </svg>

      <!-- Âè≥‰æßÔºöÁõÆÊ†áÂπ≥Âè∞BotÂàóË°® -->
      <div class="bot-panel right-panel">
        <div class="panel-header">
          <h3>ü§ñ ÁõÆÊ†áÂπ≥Âè∞ÔºàÊé•Êî∂Ôºâ</h3>
          <el-input
            v-model="rightSearch"
            placeholder="ÊêúÁ¥¢Bot..."
            clearable
            size="small"
            style="width: 200px"
          >
            <template #prefix>
              <el-icon><Search /></el-icon>
            </template>
          </el-input>
        </div>

        <div class="panel-content" ref="rightPanel">
          <div
            v-for="platform in ['Discord', 'Telegram', 'È£û‰π¶']"
            :key="platform"
            class="platform-group"
          >
            <div class="platform-header">
              <el-icon v-if="platform === 'Discord'"><ChatDotSquare /></el-icon>
              <el-icon v-else-if="platform === 'Telegram'"><Connection /></el-icon>
              <el-icon v-else><Message /></el-icon>
              <span>{{ platform }}</span>
            </div>

            <div class="bot-list">
              <div
                v-for="bot in getBotsBy Platform(platform)"
                :key="bot.id"
                :ref="`bot-${bot.id}`"
                class="bot-item"
                :class="{ 'is-drop-target': dropTargetBot === bot.id }"
                :data-bot-id="bot.id"
                @dragover.prevent="handleBotDragOver($event, bot)"
                @dragleave="handleBotDragLeave"
                @drop="handleBotDrop($event, bot)"
              >
                <div class="bot-info">
                  <div class="bot-icon">{{ platform.substring(0, 1) }}</div>
                  <div class="bot-details">
                    <div class="bot-name">{{ bot.name }}</div>
                    <div class="bot-meta">
                      {{ bot.target_channel || 'ID: ' + bot.id }}
                    </div>
                  </div>
                </div>
                <el-tag
                  v-if="getBotMappingCount(bot.id) > 0"
                  size="small"
                  type="primary"
                >
                  {{ getBotMappingCount(bot.id) }}‰∏™Êò†Â∞Ñ
                </el-tag>
              </div>
            </div>

            <el-empty
              v-if="getBotsByPlatform(platform).length === 0"
              description="ÊöÇÊó†Bot"
              :image-size="60"
            >
              <el-button type="primary" size="small" @click="goToAddBot(platform)">
                Ê∑ªÂä†{{ platform }} Bot
              </el-button>
            </el-empty>
          </div>
        </div>
      </div>
    </div>

    <!-- Â∫ïÈÉ®Êò†Â∞ÑÈ¢ÑËßàÈù¢Êùø -->
    <div class="mapping-preview-panel">
      <div class="preview-header">
        <h3>üìã Êò†Â∞ÑÈ¢ÑËßàÔºà{{ mappings.length }}‰∏™Êò†Â∞ÑÂÖ≥Á≥ªÔºâ</h3>
        <el-button size="small" @click="exportMappings">
          <el-icon><Download /></el-icon>
          ÂØºÂá∫ÈÖçÁΩÆ
        </el-button>
      </div>

      <div class="preview-content">
        <div
          v-for="(mapping, index) in mappings"
          :key="index"
          class="mapping-item"
        >
          <div class="mapping-source">
            <el-icon><ChatDotRound /></el-icon>
            <span>{{ getChannelName(mapping.kook_channel_id) }}</span>
          </div>
          <div class="mapping-arrow">
            <el-icon><Right /></el-icon>
          </div>
          <div class="mapping-targets">
            <div
              v-for="target in mapping.targets"
              :key="target.bot_id"
              class="mapping-target"
            >
              <el-tag size="small" :type="getPlatformColor(target.platform)">
                {{ target.platform }}
              </el-tag>
              <span>{{ target.bot_name }}</span>
            </div>
          </div>
          <el-button
            type="danger"
            size="small"
            circle
            @click="removeMapping(index)"
          >
            <el-icon><Close /></el-icon>
          </el-button>
        </div>

        <el-empty
          v-if="mappings.length === 0"
          description="ÊöÇÊó†Êò†Â∞ÑÂÖ≥Á≥ªÔºåËØ∑ÊãñÊãΩÂ∑¶‰æßÈ¢ëÈÅìÂà∞Âè≥‰æßBotÂª∫Á´ãÊò†Â∞Ñ"
          :image-size="100"
        />
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted, nextTick } from 'vue'
import { ElMessage, ElMessageBox } from 'element-plus'
import { useRouter } from 'vue-router'
import api from '@/api'

const router = useRouter()

// Áä∂ÊÄÅ
const loading = ref(false)
const saving = ref(false)
const showConnections = ref(true)
const leftSearch = ref('')
const rightSearch = ref('')
const dropTargetBot = ref(null)
const draggingChannel = ref(null)

// Êï∞ÊçÆ
const kookServers = ref([])
const bots = ref([])
const mappings = ref([])
const connections = ref([])
const tempConnection = ref(null)

// ÂºïÁî®
const editorContainer = ref(null)
const leftPanel = ref(null)
const rightPanel = ref(null)

// ÁîªÂ∏ÉÂ∞∫ÂØ∏
const canvasWidth = ref(400)
const canvasHeight = ref(800)

// Á≠õÈÄâÂêéÁöÑKOOKÊúçÂä°Âô®
const filteredKookServers = computed(() => {
  if (!leftSearch.value) return kookServers.value

  const keyword = leftSearch.value.toLowerCase()
  return kookServers.value.map(server => ({
    ...server,
    channels: server.channels?.filter(ch =>
      ch.name.toLowerCase().includes(keyword)
    ) || []
  })).filter(server => server.channels.length > 0)
})

// ÊåâÂπ≥Âè∞Á≠õÈÄâBot
const getBotsByPlatform = (platform) => {
  let platformBots = bots.value.filter(bot => bot.platform === platform.toLowerCase())
  
  if (rightSearch.value) {
    const keyword = rightSearch.value.toLowerCase()
    platformBots = platformBots.filter(bot =>
      bot.name.toLowerCase().includes(keyword)
    )
  }
  
  return platformBots
}

// Ê£ÄÊü•È¢ëÈÅìÊòØÂê¶Â∑≤Êò†Â∞Ñ
const isMapped = (channelId) => {
  return mappings.value.some(m => m.kook_channel_id === channelId)
}

// Ëé∑ÂèñÈ¢ëÈÅìÁöÑÊò†Â∞ÑÊï∞Èáè
const getMappingCount = (channelId) => {
  const mapping = mappings.value.find(m => m.kook_channel_id === channelId)
  return mapping?.targets?.length || 0
}

// Ëé∑ÂèñBotÁöÑÊò†Â∞ÑÊï∞Èáè
const getBotMappingCount = (botId) => {
  let count = 0
  mappings.value.forEach(mapping => {
    if (mapping.targets.some(t => t.bot_id === botId)) {
      count++
    }
  })
  return count
}

// Ëé∑ÂèñÈ¢ëÈÅìÂêçÁß∞
const getChannelName = (channelId) => {
  for (const server of kookServers.value) {
    const channel = server.channels?.find(ch => ch.id === channelId)
    if (channel) return channel.name
  }
  return channelId
}

// Ëé∑ÂèñÂπ≥Âè∞È¢úËâ≤
const getPlatformColor = (platform) => {
  const colors = {
    'discord': 'primary',
    'telegram': 'info',
    'feishu': 'success',
    'È£û‰π¶': 'success'
  }
  return colors[platform.toLowerCase()] || 'info'
}

// ÊãñÊãΩÂºÄÂßã
const handleDragStart = (event, channel, type) => {
  draggingChannel.value = channel
  event.dataTransfer.effectAllowed = 'copy'
  event.dataTransfer.setData('text/plain', JSON.stringify({
    type,
    data: channel
  }))
  
  // Ê∑ªÂä†ÊãñÊãΩÊ†∑Âºè
  event.target.classList.add('is-dragging')
}

// ÊãñÊãΩÁªìÊùü
const handleDragEnd = (event) => {
  event.target.classList.remove('is-dragging')
  draggingChannel.value = null
  tempConnection.value = null
}

// BotÊãñÊãΩÁªèËøá
const handleBotDragOver = (event, bot) => {
  event.preventDefault()
  dropTargetBot.value = bot.id
  
  // ËÆ°ÁÆó‰∏¥Êó∂ËøûÊé•Á∫ø
  if (draggingChannel.value) {
    updateTempConnection(event)
  }
}

// BotÊãñÊãΩÁ¶ªÂºÄ
const handleBotDragLeave = () => {
  dropTargetBot.value = null
}

// BotÊé•Êî∂ÊãñÊîæ
const handleBotDrop = (event, bot) => {
  event.preventDefault()
  dropTargetBot.value = null
  tempConnection.value = null
  
  try {
    const data = JSON.parse(event.dataTransfer.getData('text/plain'))
    
    if (data.type === 'kook' && data.data) {
      const channel = data.data
      addMapping(channel, bot)
    }
  } catch (error) {
    console.error('Â§ÑÁêÜÊãñÊîæÂ§±Ë¥•:', error)
  }
}

// Êõ¥Êñ∞‰∏¥Êó∂ËøûÊé•Á∫ø
const updateTempConnection = (event) => {
  if (!draggingChannel.value || !editorContainer.value) return

  // Ëé∑ÂèñËµ∑ÁÇπ‰ΩçÁΩÆÔºàÂ∑¶‰æßÈ¢ëÈÅìÔºâ
  const channelEl = document.querySelector(`[data-channel-id="${draggingChannel.value.id}"]`)
  if (!channelEl) return

  const containerRect = editorContainer.value.getBoundingClientRect()
  const channelRect = channelEl.getBoundingClientRect()
  
  const startX = channelRect.right - containerRect.left
  const startY = channelRect.top - containerRect.top + channelRect.height / 2
  
  // Ëé∑ÂèñÁªàÁÇπ‰ΩçÁΩÆÔºàÈº†Ê†á‰ΩçÁΩÆÔºâ
  const endX = event.clientX - containerRect.left
  const endY = event.clientY - containerRect.top
  
  // ÁîüÊàêË¥ùÂ°ûÂ∞îÊõ≤Á∫øË∑ØÂæÑ
  tempConnection.value = generateCurvePath(startX, startY, endX, endY)
}

// ÁîüÊàêË¥ùÂ°ûÂ∞îÊõ≤Á∫øË∑ØÂæÑ
const generateCurvePath = (x1, y1, x2, y2) => {
  const mx = (x1 + x2) / 2
  return `M ${x1} ${y1} C ${mx} ${y1}, ${mx} ${y2}, ${x2} ${y2}`
}

// Ê∑ªÂä†Êò†Â∞Ñ
const addMapping = (channel, bot) => {
  // Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú®
  const existing = mappings.value.find(m => m.kook_channel_id === channel.id)
  
  if (existing) {
    // Â∑≤Â≠òÂú®ÔºåÊ∑ªÂä†ÁõÆÊ†á
    if (!existing.targets.some(t => t.bot_id === bot.id)) {
      existing.targets.push({
        bot_id: bot.id,
        bot_name: bot.name,
        platform: bot.platform,
        target_channel: bot.target_channel || ''
      })
      ElMessage.success(`Â∑≤Â∞Ü ${channel.name} Ê∑ªÂä†Âà∞ ${bot.name}`)
    } else {
      ElMessage.warning('ËØ•Êò†Â∞ÑÂ∑≤Â≠òÂú®')
    }
  } else {
    // ÂàõÂª∫Êñ∞Êò†Â∞Ñ
    mappings.value.push({
      kook_channel_id: channel.id,
      kook_channel_name: channel.name,
      kook_server_id: channel.server_id,
      targets: [{
        bot_id: bot.id,
        bot_name: bot.name,
        platform: bot.platform,
        target_channel: bot.target_channel || ''
      }]
    })
    ElMessage.success(`Â∑≤ÂàõÂª∫Êò†Â∞ÑÔºö${channel.name} ‚Üí ${bot.name}`)
  }
  
  // Êõ¥Êñ∞ËøûÊé•Á∫ø
  updateConnections()
}

// Âà†Èô§Êò†Â∞Ñ
const removeMapping = (index) => {
  const mapping = mappings.value[index]
  ElMessageBox.confirm(
    `Á°ÆÂÆöË¶ÅÂà†Èô§"${mapping.kook_channel_name}"ÁöÑÊò†Â∞ÑÂêóÔºü`,
    'Á°ÆËÆ§Âà†Èô§',
    {
      confirmButtonText: 'Á°ÆÂÆö',
      cancelButtonText: 'ÂèñÊ∂à',
      type: 'warning'
    }
  ).then(() => {
    mappings.value.splice(index, 1)
    updateConnections()
    ElMessage.success('Â∑≤Âà†Èô§Êò†Â∞Ñ')
  }).catch(() => {})
}

// Âà†Èô§ËøûÊé•Á∫ø
const removeConnection = (connection) => {
  const mapping = mappings.value.find(
    m => m.kook_channel_id === connection.channelId && 
         m.targets.some(t => t.bot_id === connection.botId)
  )
  
  if (mapping) {
    mapping.targets = mapping.targets.filter(t => t.bot_id !== connection.botId)
    if (mapping.targets.length === 0) {
      const index = mappings.value.indexOf(mapping)
      mappings.value.splice(index, 1)
    }
    updateConnections()
    ElMessage.success('Â∑≤Âà†Èô§ËøûÊé•')
  }
}

// Êõ¥Êñ∞ËøûÊé•Á∫ø
const updateConnections = async () => {
  await nextTick()
  
  if (!editorContainer.value || !showConnections.value) return

  connections.value = []
  const containerRect = editorContainer.value.getBoundingClientRect()

  mappings.value.forEach(mapping => {
    const channelEl = document.querySelector(`[data-channel-id="${mapping.kook_channel_id}"]`)
    if (!channelEl) return

    const channelRect = channelEl.getBoundingClientRect()
    const startX = channelRect.right - containerRect.left
    const startY = channelRect.top - containerRect.top + channelRect.height / 2

    mapping.targets.forEach(target => {
      const botEl = document.querySelector(`[data-bot-id="${target.bot_id}"]`)
      if (!botEl) return

      const botRect = botEl.getBoundingClientRect()
      const endX = botRect.left - containerRect.left
      const endY = botRect.top - containerRect.top + botRect.height / 2

      connections.value.push({
        channelId: mapping.kook_channel_id,
        botId: target.bot_id,
        path: generateCurvePath(startX, startY, endX, endY)
      })
    })
  })
}

// Êô∫ËÉΩÊò†Â∞Ñ
const smartMapping = async () => {
  try {
    ElMessageBox.confirm(
      'Êô∫ËÉΩÊò†Â∞ÑÂ∞ÜÊ†πÊçÆÈ¢ëÈÅìÂêçÁß∞Ëá™Âä®ÂåπÈÖçBotÔºåÂèØËÉΩ‰ºöË¶ÜÁõñÈÉ®ÂàÜÁé∞ÊúâÊò†Â∞Ñ„ÄÇÊòØÂê¶ÁªßÁª≠Ôºü',
      'Êô∫ËÉΩÊò†Â∞Ñ',
      {
        confirmButtonText: 'ÂºÄÂßãÂåπÈÖç',
        cancelButtonText: 'ÂèñÊ∂à',
        type: 'info'
      }
    ).then(async () => {
      loading.value = true
      
      const response = await api.post('/api/smart-mapping-enhanced/auto-match', {
        kook_channels: getAllChannels(),
        bots: bots.value
      })
      
      if (response.success) {
        const matched = response.mappings || []
        
        // ÂêàÂπ∂Âà∞Áé∞ÊúâÊò†Â∞Ñ
        matched.forEach(newMapping => {
          const existing = mappings.value.find(
            m => m.kook_channel_id === newMapping.kook_channel_id
          )
          
          if (existing) {
            // ÂêàÂπ∂ÁõÆÊ†á
            newMapping.targets.forEach(target => {
              if (!existing.targets.some(t => t.bot_id === target.bot_id)) {
                existing.targets.push(target)
              }
            })
          } else {
            mappings.value.push(newMapping)
          }
        })
        
        updateConnections()
        ElMessage.success(`Êô∫ËÉΩÂåπÈÖçÂÆåÊàêÔºÅÂàõÂª∫‰∫Ü ${matched.length} ‰∏™Êò†Â∞Ñ`)
      }
    }).catch(() => {})
  } catch (error) {
    console.error('Êô∫ËÉΩÊò†Â∞ÑÂ§±Ë¥•:', error)
    ElMessage.error('Êô∫ËÉΩÊò†Â∞ÑÂ§±Ë¥•Ôºö' + (error.response?.data?.detail || error.message))
  } finally {
    loading.value = false
  }
}

// Ëé∑ÂèñÊâÄÊúâÈ¢ëÈÅì
const getAllChannels = () => {
  const channels = []
  kookServers.value.forEach(server => {
    server.channels?.forEach(channel => {
      channels.push({
        ...channel,
        server_id: server.id,
        server_name: server.name
      })
    })
  })
  return channels
}

// Ê∏ÖÁ©∫ÊâÄÊúâÊò†Â∞Ñ
const clearAllMappings = () => {
  if (mappings.value.length === 0) {
    ElMessage.info('ÂΩìÂâçÊ≤°ÊúâÊò†Â∞Ñ')
    return
  }

  ElMessageBox.confirm(
    `Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ÊâÄÊúâ ${mappings.value.length} ‰∏™Êò†Â∞ÑÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§çÔºÅ`,
    'Á°ÆËÆ§Ê∏ÖÁ©∫',
    {
      confirmButtonText: 'Á°ÆÂÆöÊ∏ÖÁ©∫',
      cancelButtonText: 'ÂèñÊ∂à',
      type: 'warning'
    }
  ).then(() => {
    mappings.value = []
    connections.value = []
    ElMessage.success('Â∑≤Ê∏ÖÁ©∫ÊâÄÊúâÊò†Â∞Ñ')
  }).catch(() => {})
}

// ‰øùÂ≠òÊò†Â∞Ñ
const saveMappings = async () => {
  if (mappings.value.length === 0) {
    ElMessage.warning('ËØ∑ÂÖàÂàõÂª∫Ëá≥Â∞ë‰∏Ä‰∏™Êò†Â∞Ñ')
    return
  }

  try {
    saving.value = true
    
    const response = await api.post('/api/mappings/batch-save', {
      mappings: mappings.value
    })
    
    if (response.success) {
      ElMessage.success('‚úÖ Êò†Â∞ÑÂ∑≤‰øùÂ≠òÔºÅ')
    }
  } catch (error) {
    console.error('‰øùÂ≠òÊò†Â∞ÑÂ§±Ë¥•:', error)
    ElMessage.error('‰øùÂ≠òÂ§±Ë¥•Ôºö' + (error.response?.data?.detail || error.message))
  } finally {
    saving.value = false
  }
}

// ÂØºÂá∫Êò†Â∞ÑÈÖçÁΩÆ
const exportMappings = () => {
  const data = JSON.stringify(mappings.value, null, 2)
  const blob = new Blob([data], { type: 'application/json' })
  const url = URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  a.download = `mapping-config-${Date.now()}.json`
  a.click()
  URL.revokeObjectURL(url)
  ElMessage.success('Êò†Â∞ÑÈÖçÁΩÆÂ∑≤ÂØºÂá∫')
}

// ÂâçÂæÄÊ∑ªÂä†Bot
const goToAddBot = (platform) => {
  router.push(`/bots?platform=${platform.toLowerCase()}`)
}

// Âä†ËΩΩÊï∞ÊçÆ
const loadData = async () => {
  try {
    loading.value = true
    
    // Âä†ËΩΩÊúçÂä°Âô®ÂíåÈ¢ëÈÅì
    const serversRes = await api.get('/api/accounts/servers')
    if (serversRes.success) {
      kookServers.value = serversRes.servers || []
    }
    
    // Âä†ËΩΩBotÂàóË°®
    const botsRes = await api.get('/api/bots')
    if (botsRes.success) {
      bots.value = botsRes.bots || []
    }
    
    // Âä†ËΩΩÁé∞ÊúâÊò†Â∞Ñ
    const mappingsRes = await api.get('/api/mappings')
    if (mappingsRes.success) {
      mappings.value = mappingsRes.mappings || []
    }
    
    // Êõ¥Êñ∞ËøûÊé•Á∫ø
    await nextTick()
    updateConnections()
    
  } catch (error) {
    console.error('Âä†ËΩΩÊï∞ÊçÆÂ§±Ë¥•:', error)
    ElMessage.error('Âä†ËΩΩÂ§±Ë¥•Ôºö' + (error.response?.data?.detail || error.message))
  } finally {
    loading.value = false
  }
}

// ÁõëÂê¨Á™óÂè£Â§ßÂ∞èÂèòÂåñ
const handleResize = () => {
  if (editorContainer.value) {
    const rect = editorContainer.value.getBoundingClientRect()
    canvasWidth.value = rect.width
    canvasHeight.value = rect.height
    updateConnections()
  }
}

onMounted(() => {
  loadData()
  
  // ÁõëÂê¨Á™óÂè£Â§ßÂ∞èÂèòÂåñ
  window.addEventListener('resize', handleResize)
  handleResize()
})
</script>

<style scoped>
.mapping-visual-editor-ultra {
  height: 100%;
  display: flex;
  flex-direction: column;
  background: #f5f7fa;
}

.editor-toolbar {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 16px 20px;
  background: white;
  border-bottom: 1px solid #e4e7ed;
}

.editor-main {
  flex: 1;
  display: flex;
  gap: 20px;
  padding: 20px;
  position: relative;
  overflow: hidden;
}

/* Èù¢ÊùøÊ†∑Âºè */
.channel-panel,
.bot-panel {
  flex: 1;
  background: white;
  border-radius: 12px;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.panel-header {
  padding: 20px;
  border-bottom: 1px solid #e4e7ed;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.panel-header h3 {
  margin: 0;
  font-size: 18px;
  font-weight: 600;
  color: #303133;
}

.panel-content {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
}

/* ÊúçÂä°Âô®ÁªÑ */
.server-group {
  margin-bottom: 20px;
}

.server-header {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 16px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border-radius: 8px;
  font-weight: 600;
  margin-bottom: 12px;
}

.channel-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

/* È¢ëÈÅìÈ°π */
.channel-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 16px;
  background: white;
  border: 2px solid #e4e7ed;
  border-radius: 8px;
  cursor: grab;
  transition: all 0.3s;
}

.channel-item:hover {
  border-color: #409eff;
  background: #ecf5ff;
  transform: translateX(4px);
}

.channel-item.is-dragging {
  opacity: 0.5;
  cursor: grabbing;
}

.channel-item.is-mapped {
  border-color: #67c23a;
  background: #f0f9ff;
}

/* Âπ≥Âè∞ÁªÑ */
.platform-group {
  margin-bottom: 20px;
}

.platform-header {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 16px;
  background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
  color: white;
  border-radius: 8px;
  font-weight: 600;
  margin-bottom: 12px;
}

.bot-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

/* BotÈ°π */
.bot-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  background: white;
  border: 2px dashed #e4e7ed;
  border-radius: 8px;
  transition: all 0.3s;
}

.bot-item.is-drop-target {
  border-color: #67c23a;
  background: #f0f9ff;
  border-style: solid;
  transform: scale(1.05);
  box-shadow: 0 4px 12px rgba(103, 194, 58, 0.3);
}

.bot-info {
  display: flex;
  align-items: center;
  gap: 12px;
}

.bot-icon {
  width: 40px;
  height: 40px;
  border-radius: 8px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  font-size: 18px;
}

.bot-details {
  display: flex;
  flex-direction: column;
}

.bot-name {
  font-weight: 600;
  color: #303133;
}

.bot-meta {
  font-size: 12px;
  color: #909399;
}

/* SVGËøûÊé•Á∫ø */
.connections-canvas {
  position: absolute;
  top: 0;
  left: 0;
  pointer-events: none;
  z-index: 1;
}

.connection-line {
  pointer-events: stroke;
  cursor: pointer;
  transition: stroke-width 0.3s;
}

.connection-line:hover {
  stroke-width: 5;
  filter: drop-shadow(0 0 4px rgba(64, 158, 255, 0.6));
}

.temp-connection-line {
  opacity: 0.6;
  animation: dash 1s linear infinite;
}

@keyframes dash {
  to {
    stroke-dashoffset: -10;
  }
}

/* Êò†Â∞ÑÈ¢ÑËßàÈù¢Êùø */
.mapping-preview-panel {
  background: white;
  border-top: 1px solid #e4e7ed;
  max-height: 300px;
  display: flex;
  flex-direction: column;
}

.preview-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 20px;
  border-bottom: 1px solid #e4e7ed;
}

.preview-header h3 {
  margin: 0;
  font-size: 16px;
  font-weight: 600;
}

.preview-content {
  flex: 1;
  overflow-y: auto;
  padding: 16px 20px;
}

.mapping-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px;
  background: #f5f7fa;
  border-radius: 8px;
  margin-bottom: 12px;
}

.mapping-source {
  display: flex;
  align-items: center;
  gap: 8px;
  min-width: 200px;
  font-weight: 600;
  color: #303133;
}

.mapping-arrow {
  color: #409eff;
  font-size: 20px;
}

.mapping-targets {
  flex: 1;
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.mapping-target {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  background: white;
  border-radius: 6px;
  font-size: 14px;
}
</style>
