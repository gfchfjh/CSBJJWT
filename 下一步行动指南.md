# 下一步行动指南

**基于代码完成度评估的具体行动建议**

---

## 🎯 当前状态

- ✅ 代码完成度: **82%**
- ⚠️ 真实环境验证: **0%**
- ❌ 打包系统: **40%**
- ⚠️ 测试覆盖: **0%**

**结论**: 代码实现基本完成，但**未经真实环境验证，无法打包发布**

---

## 🔴 第1优先级：真实环境验证（1-3天）

### 为什么这是最紧急的？

当前所有DOM选择器都是**基于推测**编写的，可能与KOOK实际网页结构**完全不匹配**。如果不先验证，后续所有工作都可能白费。

### 具体步骤

#### 步骤1: 手动登录KOOK网页版

```bash
# 1. 在浏览器打开KOOK
https://www.kookapp.cn/app

# 2. 登录你的账号

# 3. 打开开发者工具（F12）
- 切换到 Elements/元素 标签
- 切换到 Network/网络 标签
```

#### 步骤2: 查看实际DOM结构

**需要找到的元素**:

1. **服务器列表容器**
   ```javascript
   // 在Console中执行
   document.querySelector('.guild-list')  // 当前代码使用的
   // 如果返回null，说明选择器错误
   
   // 手动查找:
   // 1. 用元素选择器点击服务器列表区域
   // 2. 查看实际的class名称
   // 3. 记录下来
   ```

2. **服务器项元素**
   ```javascript
   // 查找服务器列表中的单个服务器
   document.querySelectorAll('.guild-item')
   // 记录实际class名称
   ```

3. **频道列表容器**
   ```javascript
   // 点击一个服务器后
   document.querySelector('.channel-list')
   // 记录实际class名称
   ```

4. **登录表单**
   ```javascript
   // 退出登录，重新进入登录页
   document.querySelector('input[type="email"]')
   document.querySelector('input[type="password"]')
   document.querySelector('button[type="submit"]')
   // 记录实际选择器
   ```

#### 步骤3: 抓包查看WebSocket消息

```bash
# 在Network标签
1. 筛选 WS (WebSocket)
2. 找到KOOK的WebSocket连接
3. 点击查看 Messages
4. 在频道发送测试消息
5. 观察WebSocket消息格式

# 记录JSON结构:
{
  "type": "MESSAGE_CREATE",  // 实际的事件类型是什么？
  "data": {
    "id": "...",             // 消息ID字段名
    "channel_id": "...",     // 频道ID字段名
    "content": "...",        // 内容字段名
    // ... 其他字段
  }
}
```

#### 步骤4: 更新代码中的选择器

**修改文件**: `backend/app/kook/scraper.py`

```python
# 第250行: 登录表单
await self.page.wait_for_selector('input[type="email"]', timeout=10000)
# 改为实际选择器，例如:
await self.page.wait_for_selector('.login-email-input', timeout=10000)

# 第492行: 服务器列表
await self.page.wait_for_selector('.guild-list', timeout=10000)
# 改为实际选择器

# 第498-522行: 提取服务器信息的JavaScript
# 修改所有querySelector和class名称

# 第551-597行: 提取频道信息的JavaScript
# 修改所有querySelector和class名称
```

#### 步骤5: 本地测试

```bash
# 1. 启动Redis
redis-server

# 2. 启动后端
cd backend
python -m app.main

# 3. 启动前端
cd frontend
npm run dev

# 4. 在浏览器打开
http://localhost:5173

# 5. 添加KOOK账号
- 使用Cookie登录（推荐）
- 或使用账号密码登录

# 6. 观察后端日志
- 是否成功登录？
- 是否抓取到服务器列表？
- 是否抓取到频道列表？
- 是否收到WebSocket消息？
```

#### 步骤6: 测试消息转发

```bash
# 1. 配置Discord Webhook
- 创建Discord Webhook
- 在界面中添加Bot配置
- 测试连接

# 2. 创建频道映射
- 选择KOOK频道
- 选择Discord Webhook
- 保存映射

# 3. 发送测试消息
- 在KOOK频道发送消息
- 观察Discord是否收到

# 4. 检查日志
- 查看"实时日志"页面
- 是否成功转发？
- 有什么错误？
```

---

## 🔴 第2优先级：修复发现的Bug（1-2天）

### 常见问题和解决方案

#### 问题1: 无法登录KOOK

**可能原因**:
- Cookie格式错误
- 登录选择器错误
- 需要验证码

**调试方法**:
```python
# 在 scraper.py 中添加调试代码
# 第70行后添加
await self.page.screenshot(path='login_page.png')
print(f"当前URL: {self.page.url}")
```

#### 问题2: 抓取不到服务器/频道

**可能原因**:
- 选择器错误
- 页面未加载完成
- 需要点击操作

**调试方法**:
```python
# 第492行前添加
await self.page.screenshot(path='servers_page.png')
await asyncio.sleep(3)  # 等待更长时间
```

#### 问题3: 收不到WebSocket消息

**可能原因**:
- WebSocket未监听
- 消息格式不匹配
- 事件类型错误

**调试方法**:
```python
# 第143行修改
data = json.loads(payload)
print(f"收到WebSocket消息: {data}")  # 添加这行
logger.debug(f"原始消息: {payload}")  # 添加这行
```

#### 问题4: 转发失败

**可能原因**:
- Webhook URL错误
- 消息格式错误
- 限流被触发

**调试方法**:
```bash
# 查看后端日志
tail -f logs/app.log

# 查看数据库
sqlite3 data/config.db
SELECT * FROM message_logs WHERE status='failed';
```

---

## 🟡 第3优先级：完成打包系统（3-5天）

### 只有验证通过后才开始打包

#### 步骤1: 下载Redis

**Windows**:
```bash
# 下载Redis for Windows
https://github.com/tporadowski/redis/releases/download/v5.0.14.1/Redis-x64-5.0.14.1.zip

# 解压后复制文件
redis/
  ├── redis-server.exe
  ├── redis-cli.exe
  └── redis.conf
```

**macOS**:
```bash
# 方法1: 使用Homebrew（推荐）
brew install redis --build-from-source
cp /usr/local/bin/redis-server redis/

# 方法2: 手动编译
wget https://download.redis.io/releases/redis-7.0.0.tar.gz
tar xzf redis-7.0.0.tar.gz
cd redis-7.0.0
make
cp src/redis-server ../redis/
```

**Linux**:
```bash
# 方法1: 下载二进制
wget https://download.redis.io/releases/redis-7.0.0.tar.gz
tar xzf redis-7.0.0.tar.gz
cd redis-7.0.0
make
cp src/redis-server ../redis/

# 方法2: 使用包管理器
# Ubuntu/Debian
apt-get source redis-server
# CentOS/RHEL
yum install redis --downloadonly --downloaddir=.
```

#### 步骤2: 安装Playwright Chromium

```bash
cd backend
playwright install chromium --with-deps

# 查找Chromium安装位置
# macOS/Linux
find ~ -name "chromium*" -type d 2>/dev/null | grep playwright

# Windows
# 通常在: C:\Users\用户名\AppData\Local\ms-playwright\

# 复制到项目目录（可选）
mkdir -p chromium
cp -r ~/.cache/ms-playwright/chromium-* chromium/
```

#### 步骤3: 完善PyInstaller打包脚本

**编辑**: `build/build_backend.py`

```python
import PyInstaller.__main__
import sys
from pathlib import Path

# 项目根目录
ROOT_DIR = Path(__file__).parent.parent

PyInstaller.__main__.run([
    'backend/app/main.py',              # 主程序
    '--name=kook-forwarder-backend',    # 可执行文件名
    '--onefile',                        # 打包成单个文件
    '--clean',                          # 清理临时文件
    
    # 包含数据文件
    f'--add-data={ROOT_DIR}/redis:redis',
    f'--add-data={ROOT_DIR}/chromium:chromium',
    
    # 隐藏导入
    '--hidden-import=playwright',
    '--hidden-import=playwright.sync_api',
    '--hidden-import=discord_webhook',
    '--hidden-import=telegram',
    '--hidden-import=lark_oapi',
    
    # 排除不需要的模块（减小体积）
    '--exclude-module=matplotlib',
    '--exclude-module=scipy',
    '--exclude-module=pandas',
    
    # Windows特定
    '--console' if sys.platform == 'win32' else '',
    
    # 输出目录
    f'--distpath={ROOT_DIR}/build/dist',
    f'--workpath={ROOT_DIR}/build/work',
    f'--specpath={ROOT_DIR}/build',
])
```

#### 步骤4: 测试打包后的程序

```bash
# 1. 执行打包
cd build
python build_backend.py

# 2. 找到可执行文件
# Windows: build/dist/kook-forwarder-backend.exe
# Linux/macOS: build/dist/kook-forwarder-backend

# 3. 测试运行
cd dist
./kook-forwarder-backend  # Linux/macOS
kook-forwarder-backend.exe  # Windows

# 4. 检查问题
# - Redis是否启动？
# - Chromium是否找到？
# - API是否正常？
```

#### 步骤5: Electron打包

**编辑**: `build/electron-builder.yml`

```yaml
appId: com.kookforwarder.app
productName: KOOK消息转发系统
copyright: Copyright © 2025
directories:
  output: dist-electron
files:
  - dist/**/*
  - electron/**/*
  - backend-dist/**/*  # 打包好的Python后端
extraResources:
  - redis/**/*
  - chromium/**/*

win:
  target:
    - target: nsis
      arch:
        - x64
  icon: build/icon.ico
  
mac:
  target: dmg
  icon: build/icon.icns
  category: public.app-category.utilities
  
linux:
  target: AppImage
  icon: build/icon.png
  category: Utility
```

**执行打包**:
```bash
cd frontend

# 1. 构建前端
npm run build

# 2. 复制Python后端
cp -r ../build/dist ../frontend/backend-dist

# 3. 打包Electron
# Windows
npm run electron:build -- --win

# macOS
npm run electron:build -- --mac

# Linux
npm run electron:build -- --linux appimage
```

#### 步骤6: 制作应用图标

**Windows (.ico)**:
```bash
# 使用在线工具转换PNG到ICO
# https://www.icoconverter.com/
# 或使用ImageMagick
convert icon.png -define icon:auto-resize=256,128,64,48,32,16 icon.ico
```

**macOS (.icns)**:
```bash
# 创建iconset
mkdir icon.iconset
sips -z 16 16 icon.png --out icon.iconset/icon_16x16.png
sips -z 32 32 icon.png --out icon.iconset/icon_16x16@2x.png
sips -z 32 32 icon.png --out icon.iconset/icon_32x32.png
# ... 其他尺寸
iconutil -c icns icon.iconset
```

**Linux (.png)**:
```bash
# 直接使用PNG，尺寸512x512
cp icon.png build/icon.png
```

---

## 🟢 第4优先级：优化和测试（可选）

### 只有前3项完成后才考虑

#### 性能优化

```python
# 1. 替换轮询为WebSocket
# frontend/src/views/Home.vue
# 删除：
setInterval(fetchStats, 10000)
# 改为：
websocket.on('stats_update', (data) => {
  stats.value = data
})
```

#### 添加测试

```bash
# 创建测试目录
mkdir backend/tests

# 安装pytest
pip install pytest pytest-asyncio

# 编写测试
# backend/tests/test_formatter.py
import pytest
from app.processors.formatter import formatter

def test_kmarkdown_to_discord():
    text = "**粗体** *斜体* `代码`"
    result = formatter.kmarkdown_to_discord(text)
    assert result == "**粗体** *斜体* `代码`"

# 运行测试
pytest backend/tests/
```

#### 图床完善

```python
# backend/app/image_server.py

import secrets
import time

# 生成Token
def generate_token():
    return secrets.token_urlsafe(32)

# 验证Token
def verify_token(token):
    # 从Redis获取Token信息
    token_data = redis_client.get(f"image_token:{token}")
    if not token_data:
        return False
    
    # 检查过期时间
    data = json.loads(token_data)
    if time.time() > data['expire_at']:
        return False
    
    return True

# 在图片访问时验证
@app.get("/images/{filename}")
async def serve_image(filename: str, token: str = None):
    if not verify_token(token):
        raise HTTPException(status_code=403, detail="Invalid token")
    
    # ... 返回图片
```

---

## 📋 每日检查清单

### 每天开始工作前

- [ ] 拉取最新代码: `git pull`
- [ ] 检查依赖更新: `pip list --outdated`
- [ ] 查看TODO.md更新
- [ ] 检查GitHub Issues

### 每天结束工作时

- [ ] 提交代码: `git commit -m "描述"`
- [ ] 推送代码: `git push`
- [ ] 更新TODO.md进度
- [ ] 记录遇到的问题
- [ ] 规划明天任务

---

## 🆘 遇到问题怎么办？

### 调试技巧

1. **启用详细日志**
   ```python
   # backend/app/config.py
   log_level: str = "DEBUG"  # 改为DEBUG
   ```

2. **使用调试器**
   ```python
   # 在代码中添加断点
   import pdb; pdb.set_trace()
   
   # 或使用IDE调试器（VSCode/PyCharm）
   ```

3. **查看网络请求**
   ```bash
   # 浏览器开发者工具 → Network
   # 查看所有API请求和响应
   ```

4. **检查数据库**
   ```bash
   sqlite3 backend/data/config.db
   .tables
   SELECT * FROM message_logs LIMIT 10;
   ```

### 常见错误解决

**错误**: `ModuleNotFoundError: No module named 'playwright'`
```bash
pip install playwright
playwright install
```

**错误**: `Connection refused (Redis)`
```bash
# 启动Redis
redis-server

# 或检查配置
# backend/app/config.py
redis_host: str = "127.0.0.1"
redis_port: int = 6379
```

**错误**: `CORS policy` (前端无法访问API)
```python
# backend/app/main.py
# 确认CORS配置正确
allow_origins=["*"]  # 开发环境
allow_origins=["http://localhost:5173"]  # 生产环境
```

---

## 🎯 里程碑目标

### 第1周结束

- [x] ✅ 代码基本完成（当前状态）
- [ ] ✅ 真实环境验证通过
- [ ] ✅ 可以正常抓取KOOK消息
- [ ] ✅ 可以转发到三大平台
- [ ] ✅ 主要Bug修复完成

### 第2周结束

- [ ] ✅ 打包系统完成
- [ ] ✅ 安装包可以生成
- [ ] ✅ 安装包测试通过
- [ ] ✅ 文档更新完成
- [ ] 🚀 发布MVP版本 (v0.9.0)

### 第4周结束

- [ ] ✅ 所有P1任务完成
- [ ] ✅ 测试覆盖率>60%
- [ ] ✅ 性能优化完成
- [ ] ✅ 用户反馈良好
- [ ] 🚀 发布正式版 (v1.0.0)

---

## 📞 需要帮助？

### 项目资源

- **代码仓库**: https://github.com/gfchfjh/CSBJJWT.git
- **问题反馈**: GitHub Issues
- **开发文档**: docs/开发指南.md
- **用户文档**: docs/用户手册.md

### 学习资源

- **Playwright文档**: https://playwright.dev/python/
- **FastAPI文档**: https://fastapi.tiangolo.com/
- **Vue 3文档**: https://vuejs.org/
- **Element Plus文档**: https://element-plus.org/

---

**记住**: 

1. **先验证，后打包** - 不要在未验证的代码上浪费时间打包
2. **小步快跑** - 每完成一个功能就测试，不要等到最后
3. **记录问题** - 遇到的每个问题都记录下来，方便后续参考
4. **定期备份** - 每天提交代码，避免数据丢失

**祝开发顺利！** 🚀
